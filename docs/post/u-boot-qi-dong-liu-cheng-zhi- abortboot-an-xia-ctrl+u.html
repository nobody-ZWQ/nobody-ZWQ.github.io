<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="### **代码调用跟踪**
```
u-boot.lds:(arch/arm/cpu/u-boot.lds)
    |-->_start:(arch/arm/lib/vectors.S)
        |-->reset(arch/arm/cpu/armv7/start.S)   
            |-->save_boot_params(arch/arm/cpu/armv7/start.S)/*将引导参数保存到内存中*/
                |-->save_boot_params_ret(arch/arm/cpu/armv7/start.S)
                    |-->cpu_init_cp15(arch/arm/cpu/armv7/start.S)/*初始化*/
                    |-->cpu_init_crit(arch/arm/cpu/armv7/start.S)
                        |-->lowlevel_init(arch/arm/cpu/armv7/lowlevel_init.S)
                    |-->_main(arch/arm/lib/crt0.S)
                        |-->board_init_f_alloc_reserve(common/init/board_init.c)/*为u-boot的gd结构体分配空间*/
                        |-->board_init_f_init_reserve(common/init/board_init.c)    /*将gd结构体清零*/
                        |-->board_init_f(common/board_f.c)
                            |-->initcall_run_list(include/initcall.h)    /*初始化序列函数*/
                                |-->init_sequence_f[](common/board_f.c)    /* 初始化序列函数数组 */
                                    |-->board_early_init_f(board/freescale/mx6ull_toto/mx6ull_toto.c)/*初始化串口的IO配置*/
                                    |-->timer_init(arch/arm/imx-common/timer.c)    /*初始化内核定时器，为uboot提供时钟节拍*/
                                    |-->init_baud_rate(common/board_f.c)        /*初始化波特率*/
                                    |-->serial_init(drivers/serial/serial.c)    /*初始化串口通信设置*/
                                    |-->console_init_f(common/console.c)        /*初始化控制台*/
                                    |-->...
                        |-->relocate_code(arch/arm/lib/relocate.S)    /*主要完成镜像拷贝和重定位*/
                        |-->relocate_vectors(arch/arm/lib/relocate.S)/*重定位向量表*/
                        |-->board_init_r(common/board_r.c)/*板级初始化*/
                            |-->initcall_run_list(include/initcall.h)/*初始化序列函数*/
                                |-->init_sequence_r[](common/board_f.c)/*序列函数*/
                                    |-->initr_reloc(common/board_r.c)    /*设置 gd->flags,标记重定位完成*/
                                    |-->serial_initialize(drivers/serial/serial-uclass.c)/*初始化串口*/
                                        |-->serial_init(drivers/serial/serial-uclass.c)     /*初始化串口*/
                                    |-->initr_mmc(common/board_r.c)                         /*初始化emmc*/
                                        |-->mmc_initialize(drivers/mmc/mmc.c)
                                            |-->mmc_do_preinit(drivers/mmc/mmc.c)
                                                |-->mmc_start_init(drivers/mmc/mmc.c)
                                    |-->console_init_r(common/console.c)                /*初始化控制台*/
                                    |-->interrupt_init(arch/arm/lib/interrupts.c)        /*初始化中断*/
                                    |-->initr_net(common/board_r.c)                        /*初始化网络设备*/
                                        |-->eth_initialize(net/eth-uclass.c)
                                            |-->eth_common_init(net/eth_common.c)
                                                |-->phy_init(drivers/net/phy/phy.c)
                                            |-->uclass_first_device_check(drivers/core/uclass.c)
                                                |-->uclass_find_first_device(drivers/core/uclass.c)
                                                |-->device_probe(drivers/core/device.c)
                                                    |-->device_of_to_plat(drivers/core/device.c)
                                                        |-->drv->of_to_plat
                                                            |-->fecmxc_of_to_plat(drivers/net/fec_mxc.c)/*解析设备树信息*/
                                                    |-->device_get_uclass_id(drivers/core/device.c)
                                                    |-->uclass_pre_probe_device(drivers/core/uclass.c)
                                                    |-->drv->probe(dev)
                                                        /*drivers/net/fec_mxc.c*/
                                                        U_BOOT_DRIVER(fecmxc_gem) = {
                                                            .name    = 'fecmxc',
                                                            .id    = UCLASS_ETH,
                                                            .of_match = fecmxc_ids,
                                                            .of_to_plat = fecmxc_of_to_plat,
                                                            .probe    = fecmxc_probe,
                                                            .remove    = fecmxc_remove,
                                                            .ops    = &fecmxc_ops,
                                                            .priv_auto    = sizeof(struct fec_priv),
                                                            .plat_auto    = sizeof(struct eth_pdata),
                                                        };
                                                        |-->fecmxc_probe(drivers/net/fec_mxc.c)/*探测和初始化*/
                                                            |-->fec_get_miibus(drivers/net/fec_mxc.c)
                                                                |-->mdio_alloc(drivers/net/fec_mxc.c)
                                                                |-->bus->read = fec_phy_read;
                                                                |-->bus->write = fec_phy_write;
                                                                |-->mdio_register(common/miiphyutil.c)
                                                                |-->fec_mii_setspeed(drivers/net/fec_mxc.c)
                                                            |-->fec_phy_init(drivers/net/fec_mxc.c)
                                                                |-->device_get_phy_addr(drivers/net/fec_mxc.c)
                                                                |-->phy_connect(drivers/net/phy/phy.c)
                                                                    |-->phy_find_by_mask(drivers/net/phy/phy.c)
                                                                        |-->bus->reset(bus)
                                                                        |-->get_phy_device_by_mask(drivers/net/phy/phy.c)
                                                                            |-->create_phy_by_mask(drivers/net/phy/phy.c)
                                                                                |-->phy_device_create(drivers/net/phy/phy.c)
                                                                                    |-->phy_probe(drivers/net/phy/phy.c)
                                                                    |-->phy_connect_dev(drivers/net/phy/phy.c)
                                                                        |-->phy_reset(drivers/net/phy/phy.c)
                                                                |-->phy_config(drivers/net/phy/phy.c)
                                                                    |-->board_phy_config(drivers/net/phy/phy.c)
                                                                        |-->phydev->drv->config(phydev)
                                                                            /*drivers/net/phy/smsc.c*/
                                                                            static struct phy_driver lan8710_driver = {
                                                                                .name = 'SMSC LAN8710/LAN8720',
                                                                                .uid = 0x0007c0f0,
                                                                                .mask = 0xffff0,
                                                                                .features = PHY_BASIC_FEATURES,
                                                                                .config = &genphy_config_aneg,
                                                                                .startup = &genphy_startup,
                                                                                .shutdown = &genphy_shutdown,
                                                                            };
                                                                            |-->genphy_config_aneg(drivers/net/phy/phy.c)
                                                                                |-->phy_reset(需要手动调用)(drivers/net/phy/phy.c)
                                                                                |-->genphy_setup_forced(drivers/net/phy/phy.c)
                                                                                |-->genphy_config_advert(drivers/net/phy/phy.c)
                                                                                |-->genphy_restart_aneg(drivers/net/phy/phy.c)
                                                    |-->uclass_post_probe_device(drivers/core/uclass.c)
                                                        |-->uc_drv->post_probe(drivers/core/uclass.c)
                                                            /*net/eth-uclass.c*/
                                                            UCLASS_DRIVER(ethernet) = {
                                                                .name        = 'ethernet',
                                                                .id        = UCLASS_ETH,
                                                                .post_bind    = eth_post_bind,
                                                                .pre_unbind    = eth_pre_unbind,
                                                                .post_probe    = eth_post_probe,
                                                                .pre_remove    = eth_pre_remove,
                                                                .priv_auto    = sizeof(struct eth_uclass_priv),
                                                                .per_device_auto    = sizeof(struct eth_device_priv),
                                                                .flags        = DM_UC_FLAG_SEQ_ALIAS,
                                                            };
                                                            |-->eth_post_probe(net/eth-uclass.c)
                                                                |-->eth_write_hwaddr(drivers/core/uclass.c)
                                    |-->...
                                    |-->run_main_loop(common/board_r.c)/*主循环，处理命令*/
                                        |-->main_loop(common/main.c)
                                            |-->bootdelay_process(common/autoboot.c)    /*读取环境变量bootdelay和bootcmd的内容*/
                                            |-->autoboot_command(common/autoboot.c)        /*倒计时按下执行，没有操作执行bootcmd的参数*/
                                                |-->abortboot(common/autoboot.c)
                                                    |-->printf('Hit any key to stop autoboot: %2d ', bootdelay);
                                                    /*到这里就是我们看到uboot延时3s启动内核的地方*/
                                            |-->cli_loop(common/cli.c)    /*倒计时按下space键,执行用户输入命令*/
```

### 编译跟踪：

./zoo 

./make_uboot_imgtr_bidir.sh

./config.mk：CPU := $(CONFIG_SYS_CPU:'%'=%)

.config：CONFIG_SYS_CPU='armv7'

关于在armv7的.S和.c文件中遇到的宏定义目前初步判断其定义位置在：

u-boot/configs/zynq-hkvs_imgtr_deconfig

zynq_hkvs_imgtr_defconfig

和.config中还有

（待定，待更新）

### 1、_start函数详解

网上查阅资料了解到u-boot.lds中的_start作为启动的第一语句，继续跟_start执行的语句，其定义在vectors.S

```
_start:
#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG
    .word   CONFIG_SYS_DV_NOR_BOOT_CFG
#endif
    b   reset
    ldr pc, _undefined_instruction
    ldr pc, _software_interrupt
    ldr pc, _prefetch_abort
    ldr pc, _data_abort
    ldr pc, _not_used
    ldr pc, _irq
    ldr pc, _fiq
/*
 *************************************************************************
 *
 * Indirect vectors table
 *
 * Symbols referenced here must be defined somewhere else
 *
 *************************************************************************
 */
    .globl  _undefined_instruction
    .globl  _software_interrupt
    .globl  _prefetch_abort
    .globl  _data_abort
    .globl  _not_used
    .globl  _irq
    .globl  _fiq
_undefined_instruction: .word undefined_instruction
_software_interrupt:    .word software_interrupt
_prefetch_abort:    .word prefetch_abort
_data_abort:        .word data_abort
_not_used:      .word not_used
_irq:           .word irq
_fiq:           .word fiq
    .balignl 16,0xdeadbeef
```

中断向量表中，先进行相对跳转到reset

而reset函数定义在arch/arm/cpu/armv7/start.S

### 2、reset函数详解

```
#include <asm-offsets.h>
#include <config.h>
#include <asm/system.h>
#include <linux/linkage.h>
/*************************************************************************
 *
 * Startup Code (reset vector)
 *
 * do important init only if we don't start from memory!
 * setup Memory and board specific bits prior to relocation.
 * relocate armboot to ram
 * setup stack
 *
 *************************************************************************/
    .globl  reset
    .globl  save_boot_params_ret
reset:
    /* Allow the board to save important registers */
    b   save_boot_params
```

在reset中执行跳转，跳转到save_boot_params

```
ENTRY(save_boot_params)
    b   save_boot_params_ret        @ back to my caller
ENDPROC(save_boot_params)
```

在save_boot_params中执行跳转，跳转到save_boot_params_ret

```
save_boot_params_ret:
    /*
     * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
     * except if in HYP mode already
     */
    mrs r0, cpsr
    and r1, r0, #0x1f       @ mask mode bits
    teq r1, #0x1a           @ test for HYP mode
    bicne r0, r0, #0x1f     @ clear all mode bits
    orrne r0, r0, #0x13     @ set SVC mode
    orr r0, r0, #0xc0       @ disable FIQ and IRQ
    msr cpsr,r0
/*
 * Setup vector:
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
    /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
    mrc p15, 0, r0, c1, c0, 0   @ Read CP15 SCTLR Register
    bic r0, #CR_V               @ V = 0
    mcr p15, 0, r0, c1, c0, 0   @ Write CP15 SCTLR Register
    /* Set vector address in CP15 VBAR register */
    ldr r0, =_start
    mcr p15, 0, r0, c12, c0, 0  @Set VBAR
#endif
    /* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
    bl  cpu_init_cp15
    bl  cpu_init_crit
#endif
    bl  _main 
```

在save_boot_params_ret中执行指令：

指令分析：

![20190318104323545](../image/20190318104323545.png)

| 指令  | 使用方式                 | 作用                                                         |
| :---- | :----------------------- | :----------------------------------------------------------- |
| mrs   | `mrs r0, cpsr`           | 读取特殊寄存器cpsr的数据，并将数据写入到r0寄存器中           |
| and   | `and r1, r0, r2`         | 将r2和r0寄存器的数据相加并将和存到r1寄存器中                 |
| teq   | `teq r1, r2`             | 测试r1寄存器和r2寄存器的数据是否相等                         |
| bic   | bic r1, r1 , r2          | 根据r2中数据哪个位为1，清除r1对应的位，然后将结果存入r1。">
<meta property="og:title" content="u-boot启动流程之 abortboot按下ctrl+u">
<meta property="og:description" content="### **代码调用跟踪**
```
u-boot.lds:(arch/arm/cpu/u-boot.lds)
    |-->_start:(arch/arm/lib/vectors.S)
        |-->reset(arch/arm/cpu/armv7/start.S)   
            |-->save_boot_params(arch/arm/cpu/armv7/start.S)/*将引导参数保存到内存中*/
                |-->save_boot_params_ret(arch/arm/cpu/armv7/start.S)
                    |-->cpu_init_cp15(arch/arm/cpu/armv7/start.S)/*初始化*/
                    |-->cpu_init_crit(arch/arm/cpu/armv7/start.S)
                        |-->lowlevel_init(arch/arm/cpu/armv7/lowlevel_init.S)
                    |-->_main(arch/arm/lib/crt0.S)
                        |-->board_init_f_alloc_reserve(common/init/board_init.c)/*为u-boot的gd结构体分配空间*/
                        |-->board_init_f_init_reserve(common/init/board_init.c)    /*将gd结构体清零*/
                        |-->board_init_f(common/board_f.c)
                            |-->initcall_run_list(include/initcall.h)    /*初始化序列函数*/
                                |-->init_sequence_f[](common/board_f.c)    /* 初始化序列函数数组 */
                                    |-->board_early_init_f(board/freescale/mx6ull_toto/mx6ull_toto.c)/*初始化串口的IO配置*/
                                    |-->timer_init(arch/arm/imx-common/timer.c)    /*初始化内核定时器，为uboot提供时钟节拍*/
                                    |-->init_baud_rate(common/board_f.c)        /*初始化波特率*/
                                    |-->serial_init(drivers/serial/serial.c)    /*初始化串口通信设置*/
                                    |-->console_init_f(common/console.c)        /*初始化控制台*/
                                    |-->...
                        |-->relocate_code(arch/arm/lib/relocate.S)    /*主要完成镜像拷贝和重定位*/
                        |-->relocate_vectors(arch/arm/lib/relocate.S)/*重定位向量表*/
                        |-->board_init_r(common/board_r.c)/*板级初始化*/
                            |-->initcall_run_list(include/initcall.h)/*初始化序列函数*/
                                |-->init_sequence_r[](common/board_f.c)/*序列函数*/
                                    |-->initr_reloc(common/board_r.c)    /*设置 gd->flags,标记重定位完成*/
                                    |-->serial_initialize(drivers/serial/serial-uclass.c)/*初始化串口*/
                                        |-->serial_init(drivers/serial/serial-uclass.c)     /*初始化串口*/
                                    |-->initr_mmc(common/board_r.c)                         /*初始化emmc*/
                                        |-->mmc_initialize(drivers/mmc/mmc.c)
                                            |-->mmc_do_preinit(drivers/mmc/mmc.c)
                                                |-->mmc_start_init(drivers/mmc/mmc.c)
                                    |-->console_init_r(common/console.c)                /*初始化控制台*/
                                    |-->interrupt_init(arch/arm/lib/interrupts.c)        /*初始化中断*/
                                    |-->initr_net(common/board_r.c)                        /*初始化网络设备*/
                                        |-->eth_initialize(net/eth-uclass.c)
                                            |-->eth_common_init(net/eth_common.c)
                                                |-->phy_init(drivers/net/phy/phy.c)
                                            |-->uclass_first_device_check(drivers/core/uclass.c)
                                                |-->uclass_find_first_device(drivers/core/uclass.c)
                                                |-->device_probe(drivers/core/device.c)
                                                    |-->device_of_to_plat(drivers/core/device.c)
                                                        |-->drv->of_to_plat
                                                            |-->fecmxc_of_to_plat(drivers/net/fec_mxc.c)/*解析设备树信息*/
                                                    |-->device_get_uclass_id(drivers/core/device.c)
                                                    |-->uclass_pre_probe_device(drivers/core/uclass.c)
                                                    |-->drv->probe(dev)
                                                        /*drivers/net/fec_mxc.c*/
                                                        U_BOOT_DRIVER(fecmxc_gem) = {
                                                            .name    = 'fecmxc',
                                                            .id    = UCLASS_ETH,
                                                            .of_match = fecmxc_ids,
                                                            .of_to_plat = fecmxc_of_to_plat,
                                                            .probe    = fecmxc_probe,
                                                            .remove    = fecmxc_remove,
                                                            .ops    = &fecmxc_ops,
                                                            .priv_auto    = sizeof(struct fec_priv),
                                                            .plat_auto    = sizeof(struct eth_pdata),
                                                        };
                                                        |-->fecmxc_probe(drivers/net/fec_mxc.c)/*探测和初始化*/
                                                            |-->fec_get_miibus(drivers/net/fec_mxc.c)
                                                                |-->mdio_alloc(drivers/net/fec_mxc.c)
                                                                |-->bus->read = fec_phy_read;
                                                                |-->bus->write = fec_phy_write;
                                                                |-->mdio_register(common/miiphyutil.c)
                                                                |-->fec_mii_setspeed(drivers/net/fec_mxc.c)
                                                            |-->fec_phy_init(drivers/net/fec_mxc.c)
                                                                |-->device_get_phy_addr(drivers/net/fec_mxc.c)
                                                                |-->phy_connect(drivers/net/phy/phy.c)
                                                                    |-->phy_find_by_mask(drivers/net/phy/phy.c)
                                                                        |-->bus->reset(bus)
                                                                        |-->get_phy_device_by_mask(drivers/net/phy/phy.c)
                                                                            |-->create_phy_by_mask(drivers/net/phy/phy.c)
                                                                                |-->phy_device_create(drivers/net/phy/phy.c)
                                                                                    |-->phy_probe(drivers/net/phy/phy.c)
                                                                    |-->phy_connect_dev(drivers/net/phy/phy.c)
                                                                        |-->phy_reset(drivers/net/phy/phy.c)
                                                                |-->phy_config(drivers/net/phy/phy.c)
                                                                    |-->board_phy_config(drivers/net/phy/phy.c)
                                                                        |-->phydev->drv->config(phydev)
                                                                            /*drivers/net/phy/smsc.c*/
                                                                            static struct phy_driver lan8710_driver = {
                                                                                .name = 'SMSC LAN8710/LAN8720',
                                                                                .uid = 0x0007c0f0,
                                                                                .mask = 0xffff0,
                                                                                .features = PHY_BASIC_FEATURES,
                                                                                .config = &genphy_config_aneg,
                                                                                .startup = &genphy_startup,
                                                                                .shutdown = &genphy_shutdown,
                                                                            };
                                                                            |-->genphy_config_aneg(drivers/net/phy/phy.c)
                                                                                |-->phy_reset(需要手动调用)(drivers/net/phy/phy.c)
                                                                                |-->genphy_setup_forced(drivers/net/phy/phy.c)
                                                                                |-->genphy_config_advert(drivers/net/phy/phy.c)
                                                                                |-->genphy_restart_aneg(drivers/net/phy/phy.c)
                                                    |-->uclass_post_probe_device(drivers/core/uclass.c)
                                                        |-->uc_drv->post_probe(drivers/core/uclass.c)
                                                            /*net/eth-uclass.c*/
                                                            UCLASS_DRIVER(ethernet) = {
                                                                .name        = 'ethernet',
                                                                .id        = UCLASS_ETH,
                                                                .post_bind    = eth_post_bind,
                                                                .pre_unbind    = eth_pre_unbind,
                                                                .post_probe    = eth_post_probe,
                                                                .pre_remove    = eth_pre_remove,
                                                                .priv_auto    = sizeof(struct eth_uclass_priv),
                                                                .per_device_auto    = sizeof(struct eth_device_priv),
                                                                .flags        = DM_UC_FLAG_SEQ_ALIAS,
                                                            };
                                                            |-->eth_post_probe(net/eth-uclass.c)
                                                                |-->eth_write_hwaddr(drivers/core/uclass.c)
                                    |-->...
                                    |-->run_main_loop(common/board_r.c)/*主循环，处理命令*/
                                        |-->main_loop(common/main.c)
                                            |-->bootdelay_process(common/autoboot.c)    /*读取环境变量bootdelay和bootcmd的内容*/
                                            |-->autoboot_command(common/autoboot.c)        /*倒计时按下执行，没有操作执行bootcmd的参数*/
                                                |-->abortboot(common/autoboot.c)
                                                    |-->printf('Hit any key to stop autoboot: %2d ', bootdelay);
                                                    /*到这里就是我们看到uboot延时3s启动内核的地方*/
                                            |-->cli_loop(common/cli.c)    /*倒计时按下space键,执行用户输入命令*/
```

### 编译跟踪：

./zoo 

./make_uboot_imgtr_bidir.sh

./config.mk：CPU := $(CONFIG_SYS_CPU:'%'=%)

.config：CONFIG_SYS_CPU='armv7'

关于在armv7的.S和.c文件中遇到的宏定义目前初步判断其定义位置在：

u-boot/configs/zynq-hkvs_imgtr_deconfig

zynq_hkvs_imgtr_defconfig

和.config中还有

（待定，待更新）

### 1、_start函数详解

网上查阅资料了解到u-boot.lds中的_start作为启动的第一语句，继续跟_start执行的语句，其定义在vectors.S

```
_start:
#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG
    .word   CONFIG_SYS_DV_NOR_BOOT_CFG
#endif
    b   reset
    ldr pc, _undefined_instruction
    ldr pc, _software_interrupt
    ldr pc, _prefetch_abort
    ldr pc, _data_abort
    ldr pc, _not_used
    ldr pc, _irq
    ldr pc, _fiq
/*
 *************************************************************************
 *
 * Indirect vectors table
 *
 * Symbols referenced here must be defined somewhere else
 *
 *************************************************************************
 */
    .globl  _undefined_instruction
    .globl  _software_interrupt
    .globl  _prefetch_abort
    .globl  _data_abort
    .globl  _not_used
    .globl  _irq
    .globl  _fiq
_undefined_instruction: .word undefined_instruction
_software_interrupt:    .word software_interrupt
_prefetch_abort:    .word prefetch_abort
_data_abort:        .word data_abort
_not_used:      .word not_used
_irq:           .word irq
_fiq:           .word fiq
    .balignl 16,0xdeadbeef
```

中断向量表中，先进行相对跳转到reset

而reset函数定义在arch/arm/cpu/armv7/start.S

### 2、reset函数详解

```
#include <asm-offsets.h>
#include <config.h>
#include <asm/system.h>
#include <linux/linkage.h>
/*************************************************************************
 *
 * Startup Code (reset vector)
 *
 * do important init only if we don't start from memory!
 * setup Memory and board specific bits prior to relocation.
 * relocate armboot to ram
 * setup stack
 *
 *************************************************************************/
    .globl  reset
    .globl  save_boot_params_ret
reset:
    /* Allow the board to save important registers */
    b   save_boot_params
```

在reset中执行跳转，跳转到save_boot_params

```
ENTRY(save_boot_params)
    b   save_boot_params_ret        @ back to my caller
ENDPROC(save_boot_params)
```

在save_boot_params中执行跳转，跳转到save_boot_params_ret

```
save_boot_params_ret:
    /*
     * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
     * except if in HYP mode already
     */
    mrs r0, cpsr
    and r1, r0, #0x1f       @ mask mode bits
    teq r1, #0x1a           @ test for HYP mode
    bicne r0, r0, #0x1f     @ clear all mode bits
    orrne r0, r0, #0x13     @ set SVC mode
    orr r0, r0, #0xc0       @ disable FIQ and IRQ
    msr cpsr,r0
/*
 * Setup vector:
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
    /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
    mrc p15, 0, r0, c1, c0, 0   @ Read CP15 SCTLR Register
    bic r0, #CR_V               @ V = 0
    mcr p15, 0, r0, c1, c0, 0   @ Write CP15 SCTLR Register
    /* Set vector address in CP15 VBAR register */
    ldr r0, =_start
    mcr p15, 0, r0, c12, c0, 0  @Set VBAR
#endif
    /* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
    bl  cpu_init_cp15
    bl  cpu_init_crit
#endif
    bl  _main 
```

在save_boot_params_ret中执行指令：

指令分析：

![20190318104323545](../image/20190318104323545.png)

| 指令  | 使用方式                 | 作用                                                         |
| :---- | :----------------------- | :----------------------------------------------------------- |
| mrs   | `mrs r0, cpsr`           | 读取特殊寄存器cpsr的数据，并将数据写入到r0寄存器中           |
| and   | `and r1, r0, r2`         | 将r2和r0寄存器的数据相加并将和存到r1寄存器中                 |
| teq   | `teq r1, r2`             | 测试r1寄存器和r2寄存器的数据是否相等                         |
| bic   | bic r1, r1 , r2          | 根据r2中数据哪个位为1，清除r1对应的位，然后将结果存入r1。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nobody-ZWQ.github.io/post/u-boot-qi-dong-liu-cheng-zhi-%20abortboot-an-xia-ctrl%2Bu.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>u-boot启动流程之 abortboot按下ctrl+u</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">u-boot启动流程之 abortboot按下ctrl+u</h1>
<div class="title-right">
    <a href="https://nobody-ZWQ.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/3" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h3><strong>代码调用跟踪</strong></h3>
<pre class="notranslate"><code class="notranslate">u-boot.lds:(arch/arm/cpu/u-boot.lds)
    |--&gt;_start:(arch/arm/lib/vectors.S)
        |--&gt;reset(arch/arm/cpu/armv7/start.S)   
            |--&gt;save_boot_params(arch/arm/cpu/armv7/start.S)/*将引导参数保存到内存中*/
                |--&gt;save_boot_params_ret(arch/arm/cpu/armv7/start.S)
                    |--&gt;cpu_init_cp15(arch/arm/cpu/armv7/start.S)/*初始化*/
                    |--&gt;cpu_init_crit(arch/arm/cpu/armv7/start.S)
                        |--&gt;lowlevel_init(arch/arm/cpu/armv7/lowlevel_init.S)
                    |--&gt;_main(arch/arm/lib/crt0.S)
                        |--&gt;board_init_f_alloc_reserve(common/init/board_init.c)/*为u-boot的gd结构体分配空间*/
                        |--&gt;board_init_f_init_reserve(common/init/board_init.c)    /*将gd结构体清零*/
                        |--&gt;board_init_f(common/board_f.c)
                            |--&gt;initcall_run_list(include/initcall.h)    /*初始化序列函数*/
                                |--&gt;init_sequence_f[](common/board_f.c)    /* 初始化序列函数数组 */
                                    |--&gt;board_early_init_f(board/freescale/mx6ull_toto/mx6ull_toto.c)/*初始化串口的IO配置*/
                                    |--&gt;timer_init(arch/arm/imx-common/timer.c)    /*初始化内核定时器，为uboot提供时钟节拍*/
                                    |--&gt;init_baud_rate(common/board_f.c)        /*初始化波特率*/
                                    |--&gt;serial_init(drivers/serial/serial.c)    /*初始化串口通信设置*/
                                    |--&gt;console_init_f(common/console.c)        /*初始化控制台*/
                                    |--&gt;...
                        |--&gt;relocate_code(arch/arm/lib/relocate.S)    /*主要完成镜像拷贝和重定位*/
                        |--&gt;relocate_vectors(arch/arm/lib/relocate.S)/*重定位向量表*/
                        |--&gt;board_init_r(common/board_r.c)/*板级初始化*/
                            |--&gt;initcall_run_list(include/initcall.h)/*初始化序列函数*/
                                |--&gt;init_sequence_r[](common/board_f.c)/*序列函数*/
                                    |--&gt;initr_reloc(common/board_r.c)    /*设置 gd-&gt;flags,标记重定位完成*/
                                    |--&gt;serial_initialize(drivers/serial/serial-uclass.c)/*初始化串口*/
                                        |--&gt;serial_init(drivers/serial/serial-uclass.c)     /*初始化串口*/
                                    |--&gt;initr_mmc(common/board_r.c)                         /*初始化emmc*/
                                        |--&gt;mmc_initialize(drivers/mmc/mmc.c)
                                            |--&gt;mmc_do_preinit(drivers/mmc/mmc.c)
                                                |--&gt;mmc_start_init(drivers/mmc/mmc.c)
                                    |--&gt;console_init_r(common/console.c)                /*初始化控制台*/
                                    |--&gt;interrupt_init(arch/arm/lib/interrupts.c)        /*初始化中断*/
                                    |--&gt;initr_net(common/board_r.c)                        /*初始化网络设备*/
                                        |--&gt;eth_initialize(net/eth-uclass.c)
                                            |--&gt;eth_common_init(net/eth_common.c)
                                                |--&gt;phy_init(drivers/net/phy/phy.c)
                                            |--&gt;uclass_first_device_check(drivers/core/uclass.c)
                                                |--&gt;uclass_find_first_device(drivers/core/uclass.c)
                                                |--&gt;device_probe(drivers/core/device.c)
                                                    |--&gt;device_of_to_plat(drivers/core/device.c)
                                                        |--&gt;drv-&gt;of_to_plat
                                                            |--&gt;fecmxc_of_to_plat(drivers/net/fec_mxc.c)/*解析设备树信息*/
                                                    |--&gt;device_get_uclass_id(drivers/core/device.c)
                                                    |--&gt;uclass_pre_probe_device(drivers/core/uclass.c)
                                                    |--&gt;drv-&gt;probe(dev)
                                                        /*drivers/net/fec_mxc.c*/
                                                        U_BOOT_DRIVER(fecmxc_gem) = {
                                                            .name    = "fecmxc",
                                                            .id    = UCLASS_ETH,
                                                            .of_match = fecmxc_ids,
                                                            .of_to_plat = fecmxc_of_to_plat,
                                                            .probe    = fecmxc_probe,
                                                            .remove    = fecmxc_remove,
                                                            .ops    = &amp;fecmxc_ops,
                                                            .priv_auto    = sizeof(struct fec_priv),
                                                            .plat_auto    = sizeof(struct eth_pdata),
                                                        };
                                                        |--&gt;fecmxc_probe(drivers/net/fec_mxc.c)/*探测和初始化*/
                                                            |--&gt;fec_get_miibus(drivers/net/fec_mxc.c)
                                                                |--&gt;mdio_alloc(drivers/net/fec_mxc.c)
                                                                |--&gt;bus-&gt;read = fec_phy_read;
                                                                |--&gt;bus-&gt;write = fec_phy_write;
                                                                |--&gt;mdio_register(common/miiphyutil.c)
                                                                |--&gt;fec_mii_setspeed(drivers/net/fec_mxc.c)
                                                            |--&gt;fec_phy_init(drivers/net/fec_mxc.c)
                                                                |--&gt;device_get_phy_addr(drivers/net/fec_mxc.c)
                                                                |--&gt;phy_connect(drivers/net/phy/phy.c)
                                                                    |--&gt;phy_find_by_mask(drivers/net/phy/phy.c)
                                                                        |--&gt;bus-&gt;reset(bus)
                                                                        |--&gt;get_phy_device_by_mask(drivers/net/phy/phy.c)
                                                                            |--&gt;create_phy_by_mask(drivers/net/phy/phy.c)
                                                                                |--&gt;phy_device_create(drivers/net/phy/phy.c)
                                                                                    |--&gt;phy_probe(drivers/net/phy/phy.c)
                                                                    |--&gt;phy_connect_dev(drivers/net/phy/phy.c)
                                                                        |--&gt;phy_reset(drivers/net/phy/phy.c)
                                                                |--&gt;phy_config(drivers/net/phy/phy.c)
                                                                    |--&gt;board_phy_config(drivers/net/phy/phy.c)
                                                                        |--&gt;phydev-&gt;drv-&gt;config(phydev)
                                                                            /*drivers/net/phy/smsc.c*/
                                                                            static struct phy_driver lan8710_driver = {
                                                                                .name = "SMSC LAN8710/LAN8720",
                                                                                .uid = 0x0007c0f0,
                                                                                .mask = 0xffff0,
                                                                                .features = PHY_BASIC_FEATURES,
                                                                                .config = &amp;genphy_config_aneg,
                                                                                .startup = &amp;genphy_startup,
                                                                                .shutdown = &amp;genphy_shutdown,
                                                                            };
                                                                            |--&gt;genphy_config_aneg(drivers/net/phy/phy.c)
                                                                                |--&gt;phy_reset(需要手动调用)(drivers/net/phy/phy.c)
                                                                                |--&gt;genphy_setup_forced(drivers/net/phy/phy.c)
                                                                                |--&gt;genphy_config_advert(drivers/net/phy/phy.c)
                                                                                |--&gt;genphy_restart_aneg(drivers/net/phy/phy.c)
                                                    |--&gt;uclass_post_probe_device(drivers/core/uclass.c)
                                                        |--&gt;uc_drv-&gt;post_probe(drivers/core/uclass.c)
                                                            /*net/eth-uclass.c*/
                                                            UCLASS_DRIVER(ethernet) = {
                                                                .name        = "ethernet",
                                                                .id        = UCLASS_ETH,
                                                                .post_bind    = eth_post_bind,
                                                                .pre_unbind    = eth_pre_unbind,
                                                                .post_probe    = eth_post_probe,
                                                                .pre_remove    = eth_pre_remove,
                                                                .priv_auto    = sizeof(struct eth_uclass_priv),
                                                                .per_device_auto    = sizeof(struct eth_device_priv),
                                                                .flags        = DM_UC_FLAG_SEQ_ALIAS,
                                                            };
                                                            |--&gt;eth_post_probe(net/eth-uclass.c)
                                                                |--&gt;eth_write_hwaddr(drivers/core/uclass.c)
                                    |--&gt;...
                                    |--&gt;run_main_loop(common/board_r.c)/*主循环，处理命令*/
                                        |--&gt;main_loop(common/main.c)
                                            |--&gt;bootdelay_process(common/autoboot.c)    /*读取环境变量bootdelay和bootcmd的内容*/
                                            |--&gt;autoboot_command(common/autoboot.c)        /*倒计时按下执行，没有操作执行bootcmd的参数*/
                                                |--&gt;abortboot(common/autoboot.c)
                                                    |--&gt;printf("Hit any key to stop autoboot: %2d ", bootdelay);
                                                    /*到这里就是我们看到uboot延时3s启动内核的地方*/
                                            |--&gt;cli_loop(common/cli.c)    /*倒计时按下space键,执行用户输入命令*/
</code></pre>
<h3>编译跟踪：</h3>
<p>./zoo</p>
<p>./make_uboot_imgtr_bidir.sh</p>
<p>./config.mk：CPU := $(CONFIG_SYS_CPU:"%"=%)</p>
<p>.config：CONFIG_SYS_CPU="armv7"</p>
<p>关于在armv7的.S和.c文件中遇到的宏定义目前初步判断其定义位置在：</p>
<p>u-boot/configs/zynq-hkvs_imgtr_deconfig</p>
<p>zynq_hkvs_imgtr_defconfig</p>
<p>和.config中还有</p>
<p>（待定，待更新）</p>
<h3>1、_start函数详解</h3>
<p>网上查阅资料了解到u-boot.lds中的_start作为启动的第一语句，继续跟_start执行的语句，其定义在vectors.S</p>
<pre class="notranslate"><code class="notranslate">_start:
#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG
    .word   CONFIG_SYS_DV_NOR_BOOT_CFG
#endif
    b   reset
    ldr pc, _undefined_instruction
    ldr pc, _software_interrupt
    ldr pc, _prefetch_abort
    ldr pc, _data_abort
    ldr pc, _not_used
    ldr pc, _irq
    ldr pc, _fiq
/*
 *************************************************************************
 *
 * Indirect vectors table
 *
 * Symbols referenced here must be defined somewhere else
 *
 *************************************************************************
 */
    .globl  _undefined_instruction
    .globl  _software_interrupt
    .globl  _prefetch_abort
    .globl  _data_abort
    .globl  _not_used
    .globl  _irq
    .globl  _fiq
_undefined_instruction: .word undefined_instruction
_software_interrupt:    .word software_interrupt
_prefetch_abort:    .word prefetch_abort
_data_abort:        .word data_abort
_not_used:      .word not_used
_irq:           .word irq
_fiq:           .word fiq
    .balignl 16,0xdeadbeef
</code></pre>
<p>中断向量表中，先进行相对跳转到reset</p>
<p>而reset函数定义在arch/arm/cpu/armv7/start.S</p>
<h3>2、reset函数详解</h3>
<pre class="notranslate"><code class="notranslate">#include &lt;asm-offsets.h&gt;
#include &lt;config.h&gt;
#include &lt;asm/system.h&gt;
#include &lt;linux/linkage.h&gt;
/*************************************************************************
 *
 * Startup Code (reset vector)
 *
 * do important init only if we don't start from memory!
 * setup Memory and board specific bits prior to relocation.
 * relocate armboot to ram
 * setup stack
 *
 *************************************************************************/
    .globl  reset
    .globl  save_boot_params_ret
reset:
    /* Allow the board to save important registers */
    b   save_boot_params
</code></pre>
<p>在reset中执行跳转，跳转到save_boot_params</p>
<pre class="notranslate"><code class="notranslate">ENTRY(save_boot_params)
    b   save_boot_params_ret        @ back to my caller
ENDPROC(save_boot_params)
</code></pre>
<p>在save_boot_params中执行跳转，跳转到save_boot_params_ret</p>
<pre class="notranslate"><code class="notranslate">save_boot_params_ret:
    /*
     * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
     * except if in HYP mode already
     */
    mrs r0, cpsr
    and r1, r0, #0x1f       @ mask mode bits
    teq r1, #0x1a           @ test for HYP mode
    bicne r0, r0, #0x1f     @ clear all mode bits
    orrne r0, r0, #0x13     @ set SVC mode
    orr r0, r0, #0xc0       @ disable FIQ and IRQ
    msr cpsr,r0
/*
 * Setup vector:
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))
    /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
    mrc p15, 0, r0, c1, c0, 0   @ Read CP15 SCTLR Register
    bic r0, #CR_V               @ V = 0
    mcr p15, 0, r0, c1, c0, 0   @ Write CP15 SCTLR Register
    /* Set vector address in CP15 VBAR register */
    ldr r0, =_start
    mcr p15, 0, r0, c12, c0, 0  @Set VBAR
#endif
    /* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
    bl  cpu_init_cp15
    bl  cpu_init_crit
#endif
    bl  _main 
</code></pre>
<p>在save_boot_params_ret中执行指令：</p>
<p>指令分析：</p>
<p><a target="_blank" rel="noopener noreferrer" href="../image/20190318104323545.png"><img src="../image/20190318104323545.png" alt="20190318104323545" style="max-width: 100%;"></a></p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="left">指令</th>
<th align="left">使用方式</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">mrs</td>
<td align="left"><code class="notranslate">mrs r0, cpsr</code></td>
<td align="left">读取特殊寄存器cpsr的数据，并将数据写入到r0寄存器中</td>
</tr>
<tr>
<td align="left">and</td>
<td align="left"><code class="notranslate">and r1, r0, r2</code></td>
<td align="left">将r2和r0寄存器的数据相加并将和存到r1寄存器中</td>
</tr>
<tr>
<td align="left">teq</td>
<td align="left"><code class="notranslate">teq r1, r2</code></td>
<td align="left">测试r1寄存器和r2寄存器的数据是否相等</td>
</tr>
<tr>
<td align="left">bic</td>
<td align="left">bic r1, r1 , r2</td>
<td align="left">根据r2中数据哪个位为1，清除r1对应的位，然后将结果存入r1。）</td>
</tr>
<tr>
<td align="left">orr</td>
<td align="left">orr r0, r0, r1</td>
<td align="left">根据r1中数据哪个位为1，将r0对应的位设置为1，然后将结果存入r0。</td>
</tr>
<tr>
<td align="left">msr</td>
<td align="left"><code class="notranslate">mrs cpsr, r1</code></td>
<td align="left">读取普通寄存器r1的数据，并将数据写入到特殊寄存器cpsr中</td>
</tr>
<tr>
<td align="left">bicne</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">orrne</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">cmp</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">strlo</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">addlo</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">lo</td>
<td align="left">cmp r0，r1strlo r0，[r1]</td>
<td align="left">lo作为小于条件，表示r0 &lt; r1 ，组合指令表示如果r0 &lt; r1 那么将r0存到r1寄存器指向的地址</td>
</tr>
<tr>
<td align="left">ne</td>
<td align="left"></td>
<td align="left">不相等条件</td>
</tr>
<tr>
<td align="left">eq</td>
<td align="left"></td>
<td align="left">相等条件</td>
</tr>
<tr>
<td align="left"><code class="notranslate">adr</code></td>
<td align="left"><code class="notranslate">adr	lr, here</code></td>
<td align="left">ADR指令用于计算当前指令地址加上一个偏移量得到目标地址，并将该地址存储到寄存器中将here的地址保存在lr寄存器中</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="left">寄存器</th>
<th align="left">名称</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">cpsr</td>
<td align="left">CPSR(当前程序状态寄存器)</td>
<td align="left">（1）保存最近已处理的 <a href="https://so.csdn.net/so/search?q=ALU&amp;spm=1001.2101.3001.7020" rel="nofollow">ALU</a> （算数逻辑单元）操作的信息；<br>（2）控制中断的使能与禁止；<br>（3）设置处理器的运行模式；<a target="_blank" rel="noopener noreferrer" href="../image/5bc6d780697f4f479bcfe1329fa95c54.png"><img src="../image/5bc6d780697f4f479bcfe1329fa95c54.png" alt="5bc6d780697f4f479bcfe1329fa95c54" style="max-width: 100%;"></a></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<pre class="notranslate"><code class="notranslate">mrs r0, cpsr            //将状态寄存器cpsr的数据存入到r0中
and r1, r0, #0x1f       //将r0中的数据同0x1f做加运算并将结果存到r1；实际是状态寄存器的数据同0x1f做加运算
teq r1, #0x1a           //尝试判断r1中的数据是否和0x1a相等；实际是判断状态寄存器中的数据同0x1f做加运算后结果是否为0x1a
bicne r0, r0, #0x1f     //如果r1的数据不等于0x1a，那么将r0中的[4:0]位清0；即清除工作模式
orrne r0, r0, #0x13     //如果r1的数据不等于0x1a，那么将r0中的[0:2]和第4位置1；即设置SVC模式,即超级管理员权限
orr r0, r0, #0xc0       //将r0中的第7位和第6位置1；关闭中断FIQ和IRQ
msr cpsr,r0             //将r0的数据写入到cpsr寄存器中
//总的作用是设置CPU为SVC32模式，除非已经处于HYP模式，同时禁止中断（FIQ和IRQ）；
</code></pre>
<p>SVC32模式（管理模式）：</p>
<p>SVC模式属于特权模式，可以访问受控资源，且相对sys模式多了部分在SVC模式下的影子寄存器，所以相对sys模式，可访问资源的能力相同，但拥有更多的硬件资源；从u-boot角度考虑，需要执行的事是初始化系统相关硬件资源，需要获取更多的权限，方便操作硬件，初始化硬件<br>
u-boot作为bootloader最终目的是启动Linux内核，在做好准备工作（初始化硬件，准备好kernel和rootfs等）跳转到kernel前需要满足一些条件，其中之一为cpu处于SVC模式</p>
<h3>3、cpu_init_cp15函数详解</h3>
<p><strong>MCR指令和MRC指令：</strong></p>
<p>MCR：将 <a href="https://so.csdn.net/so/search?q=ARM&amp;spm=1001.2101.3001.7020" rel="nofollow">ARM</a> 寄存器的数据写入到 CP15 协处理器寄存器中。</p>
<p>MRC：就是读 CP15 <a href="https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&amp;spm=1001.2101.3001.7020" rel="nofollow">寄存器</a>， MCR 就是写 CP15 寄存器</p>
<p>MCR 指令格式：MCR {cond} p15, , <rt>, , , </rt></p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">cond</td>
<td align="left">指令执行的条件码，如果忽略的话就表示无条件执行。</td>
</tr>
<tr>
<td align="left">opc1</td>
<td align="left">协处理器要执行的操作码</td>
</tr>
<tr>
<td align="left">Rt</td>
<td align="left">ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中</td>
</tr>
<tr>
<td align="left">CRn</td>
<td align="left">CP15 协处理器的目标寄存器</td>
</tr>
<tr>
<td align="left">CRm</td>
<td align="left">协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将CRm 设置为 C0，否则结果不可预测</td>
</tr>
<tr>
<td align="left">opc2</td>
<td align="left">可选的协处理器特定操作码，当不需要的时候要设置为 0</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>MRC 的指令格式和 MCR 一样</p>
<p>MRC 指令格式：MRC {cond} p15, , <rt>, , , </rt></p>
<p>Rt 是目标寄存器：也就是从CP15 指定寄存器读出来的数据会保存在 Rt 中</p>
<p>CRn 就是源寄存器：要读取的协处理器寄存器</p>
<p>cpu_init_cp15中执行语句的功能：</p>
<ul>
<li>1.失效 L1 I/D Cache；</li>
<li>2.禁用MMU和缓存。</li>
</ul>
<pre class="notranslate"><code class="notranslate">ENTRY(cpu_init_cp15)
    /*
     * Invalidate L1 I/D
     */
    mov r0, #0                  @ set up for MCR
    mcr p15, 0, r0, c8, c7, 0   @ invalidate TLBs           //关闭TLBs
    mcr p15, 0, r0, c7, c5, 0   @ invalidate icache         //关闭TLBs
    mcr p15, 0, r0, c7, c5, 6   @ invalidate BP array       //关闭分支预测
    mcr p15, 0, r0, c7, c10, 4  @ DSB                       //数据同步屏蔽
    mcr p15, 0, r0, c7, c5, 4   @ ISB                       //指令同步屏蔽
    //关闭TBL、icache、分支预测、
    //DSB和ISB指的分别是数据chache和指令cache同步屏蔽
    /*
     * disable MMU stuff and caches
     */
    mrc p15, 0, r0, c1, c0, 0                               //将SCTLR的值赋给r0
    bic r0, r0, #0x00002000     @ clear bits 13 (--V-)      //清零第13位，异常向量映射到0x00000000
    bic r0, r0, #0x00000007     @ clear bits 2:0 (-CAM)     //失效dcache，失效对齐检查，禁用MMU
    orr r0, r0, #0x00000002     @ set bit 1 (--A-) Align    //使能对齐检查模式
    orr r0, r0, #0x00000800     @ set bit 11 (Z---) BTB     //使能分支预测
#ifdef CONFIG_SYS_ICACHE_OFF
    bic r0, r0, #0x00001000     @ clear bit 12 (I) I-cache
#else
    orr r0, r0, #0x00001000     @ set bit 12 (I) I-cache    //使能icache
#endif
    mcr p15, 0, r0, c1, c0, 0                               //将r0的值赋给SCTLR
#ifdef CONFIG_ARM_ERRATA_716044
    mrc p15, 0, r0, c1, c0, 0   @ read system control register
    orr r0, r0, #1 &lt;&lt; 11      @ set bit #11
    mcr p15, 0, r0, c1, c0, 0   @ write system control register
#endif
#if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072))
    mrc p15, 0, r0, c15, c0, 1  @ read diagnostic register
    orr r0, r0, #1 &lt;&lt; 4           @ set bit #4
    mcr p15, 0, r0, c15, c0, 1  @ write diagnostic register
#endif
#ifdef CONFIG_ARM_ERRATA_743622
    mrc p15, 0, r0, c15, c0, 1  @ read diagnostic register
    orr r0, r0, #1 &lt;&lt; 6           @ set bit #6
    mcr p15, 0, r0, c15, c0, 1  @ write diagnostic register
#endif
#ifdef CONFIG_ARM_ERRATA_751472
    mrc p15, 0, r0, c15, c0, 1  @ read diagnostic register
    orr r0, r0, #1 &lt;&lt; 11      @ set bit #11
    mcr p15, 0, r0, c15, c0, 1  @ write diagnostic register
#endif
#ifdef CONFIG_ARM_ERRATA_761320
    mrc p15, 0, r0, c15, c0, 1  @ read diagnostic register
    orr r0, r0, #1 &lt;&lt; 21      @ set bit #21
    mcr p15, 0, r0, c15, c0, 1  @ write diagnostic register
#endif
    mov r5, lr                  @ Store my Caller                           //将lr寄存器的值保存到r5寄存器
    mrc p15, 0, r1, c0, c0, 0   @ r1 has Read Main ID Register (MIDR)
    mov r3, r1, lsr #20         @ get variant field
    and r3, r3, #0xf            @ r3 has CPU variant
    and r4, r1, #0xf            @ r4 has CPU revision
    mov r2, r3, lsl #4          @ shift variant field for combined value
    orr r2, r4, r2              @ r2 has combined CPU variant + revision    //r2中保存了大的版本号+小的版本号，即完整的版本信息
    //获取CPU版本和修订信息
#ifdef CONFIG_ARM_ERRATA_798870
    cmp r2, #0x30               @ Applies to lower than R3p0
    bge skip_errata_798870      @ skip if not affected rev
    cmp r2, #0x20               @ Applies to including and above R2p0
    blt skip_errata_798870      @ skip if not affected rev
    mrc p15, 1, r0, c15, c0, 0  @ read l2 aux ctrl reg
    orr r0, r0, #1 &lt;&lt; 7         @ Enable hazard-detect timeout
    push    {r1-r5}             @ Save the cpu info registers
    bl  v7_arch_cp15_set_l2aux_ctrl
    isb                         @ Recommended ISB after l2actlr update
    pop {r1-r5}                 @ Restore the cpu info - fall through
skip_errata_798870:
#endif
#ifdef CONFIG_ARM_ERRATA_454179
    cmp r2, #0x21               @ Only on &lt; r2p1
    bge skip_errata_454179
    mrc p15, 0, r0, c1, c0, 1   @ Read ACR
    orr r0, r0, #(0x3 &lt;&lt; 6)       @ Set DBSM(BIT7) and IBE(BIT6) bits
    push    {r1-r5}             @ Save the cpu info registers
    bl  v7_arch_cp15_set_acr
    pop {r1-r5}                 @ Restore the cpu info - fall through
skip_errata_454179:
#endif
#ifdef CONFIG_ARM_ERRATA_430973
    cmp r2, #0x21               @ Only on &lt; r2p1
    bge skip_errata_430973
    mrc p15, 0, r0, c1, c0, 1   @ Read ACR
    orr r0, r0, #(0x1 &lt;&lt; 6)       @ Set IBE bit
    push    {r1-r5}             @ Save the cpu info registers
    bl  v7_arch_cp15_set_acr
    pop {r1-r5}                 @ Restore the cpu info - fall through
skip_errata_430973:
#endif
#ifdef CONFIG_ARM_ERRATA_621766
    cmp r2, #0x21               @ Only on &lt; r2p1
    bge skip_errata_621766
    mrc p15, 0, r0, c1, c0, 1   @ Read ACR
    orr r0, r0, #(0x1 &lt;&lt; 5)       @ Set L1NEON bit
    push    {r1-r5}             @ Save the cpu info registers
    bl  v7_arch_cp15_set_acr
    pop {r1-r5}                 @ Restore the cpu info - fall through
skip_errata_621766:
#endif
    mov pc, r5                  @ back to my caller                         //子过程运行结束，跳转回去
ENDPROC(cpu_init_cp15)
</code></pre>
<p><strong>MIDR介绍：</strong></p>
<p><strong>lsr：</strong></p>
<p><strong>lsl：</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="../image/MIDR%20%E4%BB%8B%E7%BB%8D.png"><img src="../image/MIDR%20%E4%BB%8B%E7%BB%8D.png" alt="MIDR 介绍" style="max-width: 100%;"></a></p>
<p>其中从低至高第0-3 bit表示<code class="notranslate">revision</code>，代表固件版本的小版本号，如r1p3中的p3；<br>
第4-15 bit表示<code class="notranslate">part number(id)</code>，代表这款CPU在所在<code class="notranslate">vendor</code>产品中定义的产品代码，如在<code class="notranslate">HiSilicon</code>产品中，<code class="notranslate">part_id=0xd01</code>代表<code class="notranslate">Kunpeng-920</code>芯片；<br>
第16-19 bit表示<code class="notranslate">architecture</code>，即架构版本，<code class="notranslate">0x8</code>即ARMv8；<br>
第20-23 bit表示<code class="notranslate">variant</code>，即固件版本的大版本号，如r1p3中的r1；<br>
第24-31 bit表示<code class="notranslate">implementer</code>，即<code class="notranslate">vendor id</code>，如<code class="notranslate">vendor_id=0x48</code>表示<code class="notranslate">HiSilicon</code> ，vendor id是指供应商标识id</p>
<p>标识id和供应商名：</p>
<h3>4、cpu_init_crit函数详解</h3>
<p>cpu_init_crit中执行语句：跳转到函数lowlevel_init入口地址</p>
<pre class="notranslate"><code class="notranslate">ENTRY(cpu_init_crit)
    /*
     * Jump to board specific initialization...
     * The Mask ROM will have already initialized
     * basic memory. Go here to bump up clock rate and handle
     * wake up conditions.
     */
    b   lowlevel_init       @ go setup pll,mux,memory
ENDPROC(cpu_init_crit)
</code></pre>
<h3>5、lowlevel_init函数详解</h3>
<p>lowlevel_init中执行语句：</p>
<ul>
<li>1.设置SP指针为CONFIG_SYS_INIT_SP_ADDR</li>
<li>2.对sp指针做8字节对齐处理</li>
<li>3.SP减去#GD_SIZE = 248，GD_SIZE同样在generic-asm-offsets.h 中定了</li>
<li>4.对 sp 指针做8字节对齐处理</li>
<li>5.将SP保存到R9，ip和lr入栈，程序跳转到s_init（对于I.MX6ULL来说，s_init 就是个空函数）</li>
<li>6.函数一路返回，直到_main，s_init函数--&gt;函数lowlevel_ini--&gt;cpu_init_crit--&gt;save_boot_params_ret--&gt;_main。</li>
</ul>
<pre class="notranslate"><code class="notranslate">ENTRY(lowlevel_init)
    /*
     * Setup a temporary stack. Global data is not available yet.
     */
    ldr sp, =CONFIG_SYS_INIT_SP_ADDR    /* 设置sp指针为CONFIG_SYS_INIT_SP_ADDR */
    bic sp, sp, #7 /* 8-byte alignment for ABI compliance 对sp指针做8字节对齐处理 */
#ifdef CONFIG_DM
    mov r9, #0
#else
    /*
     * Set up global data for boards that still need it. This will be
     * removed soon.
     */
#ifdef CONFIG_SPL_BUILD
    ldr r9, =gdata
#else
    sub sp, sp, #GD_SIZE    /* sp减去GD_SIZE=248 */
    bic sp, sp, #7          /* 对sp指针做8字节对齐处理 */
    mov r9, sp              /* 将 sp 保存至r9寄存器 */
#endif
#endif
    /*
     * Save the old lr(passed in ip) and the current lr to stack
     */
    push    {ip, lr}        /*ip和lr入栈*/
    /*
     * Call the very early init function. This should do only the
     * absolute bare minimum to get started. It should not:
     *
     * - set up DRAM
     * - use global_data
     * - clear BSS
     * - try to start a console
     *
     * For boards with SPL this should be empty since SPL can do all of
     * this init in the SPL board_init_f() function which is called
     * immediately after this.
     */
    bl  s_init              /* 程序跳转至s_init */
    pop {ip, pc}            /* IP和pc出栈 */
ENDPROC(lowlevel_init)
</code></pre>
<h3>6、_main函数详解：</h3>
<p>函数一路返回到,执行下一条指令，跳转到_main函数入口地址，_main函数中执行的指令：</p>
<ul>
<li>1.设置sp指针为 CONFIG_SYS_INIT_SP_ADDR；</li>
<li>2.对sp指针做8字节对齐处理；</li>
<li>3.读取sp到寄存器r2里面；</li>
<li>4.调用函数board_init_f，</li>
</ul>
<h4>1、_main函数前半段操作到跳转boarf_init_f</h4>
<pre class="notranslate"><code class="notranslate">ENTRY(_main)
/*
 * Set up initial C runtime environment and call board_init_f(0).
 */
#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)
    ldr sp, =(CONFIG_SPL_STACK)
#else
    ldr sp, =(CONFIG_SYS_INIT_SP_ADDR)
#endif
    bic sp, sp, #7  /* 8-byte alignment for ABI compliance */
    mov r2, sp
    sub sp, sp, #GD_SIZE    /* allocate one GD above SP 在sp之前分配GD_SIZE大小的空间给GD*/
    bic sp, sp, #7  /* 8-byte alignment for ABI compliance 再次对sp指针进行8字节对齐*/
    mov r9, sp      /* GD is above SP ；将sp保存至r9*/
    mov r1, sp      /* 将sp保存至r1 */
    mov r0, #0      /* 将r0寄存器清0 */
clr_gd:
    cmp r1, r2              /* while not at end of GD 比较r1和r2的大小 */
    strlo   r0, [r1]        /* clear 32-bit GD word ，如果r0中的页表项不超过512MB则将r0中的页表项写入r1指向的地址，否则忽略本次操作 */
    addlo   r1, r1, #4      /* move to next，给r1寄存器值加4 */
    blo clr_gd              /* 如果上一次比较结果小于零（表示目标地址在当前指令之前），则跳转到目标地址执行 */
#if defined(CONFIG_SYS_MALLOC_F_LEN)
    sub sp, sp, #CONFIG_SYS_MALLOC_F_LEN       
    str sp, [r9, #GD_MALLOC_BASE]              
#endif
    /* mov r0, #0 not needed due to above code */
    bl  board_init_f        /* 跳转到board_init_f */
</code></pre>
<h5>进一步了解board_init_f，在board_init_f函数中核心部分是执行初始化函数序列 init_sequence_f</h5>
<pre class="notranslate"><code class="notranslate">static init_fnc_t init_sequence_f[] = {
#ifdef CONFIG_SANDBOX
    setup_ram_buf,
#endif
    setup_mon_len,  //设置gd的mon_len成员变量，也就是整个代码的长度，包括code段和bss段
    setup_fdt,      //设置gd的fdt_blod成员变量
#ifdef CONFIG_TRACE
    trace_early_init,
#endif
    initf_malloc,   //设置gd中和malloc有关的成员变量；但在zynq平台，本函数并无作用，因为其实际代码被宏限制，而该宏未定义
#if defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx)
    /* TODO: can this go into arch_cpu_init()? */
    probecpu,
#endif
    arch_cpu_init,      /* basic arch cpu dependent setup */？？？
    mark_bootstage,     /* 标记bootstage */
#ifdef CONFIG_OF_CONTROL
    fdtdec_check_fdt,
#endif
    initf_dm,           //驱动模型初始化
#if defined(CONFIG_BOARD_EARLY_INIT_F)
    board_early_init_f,
#endif
    /* TODO: can any of this go into arch_cpu_init()? */
#if defined(CONFIG_PPC) &amp;&amp; !defined(CONFIG_8xx_CPUCLK_DEFAULT)
    get_clocks,     /* get CPU and bus clocks (etc.) */
#if defined(CONFIG_TQM8xxL) &amp;&amp; !defined(CONFIG_TQM866M) \
        &amp;&amp; !defined(CONFIG_TQM885D)
    adjust_sdram_tbs_8xx,
#endif
    /* TODO: can we rename this to timer_init()? */
    init_timebase,
#endif
#if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || defined(CONFIG_BLACKFIN)
    timer_init,     /* initialize timer */ //初始化内核定时器，为uboot提供时钟节拍，在arch/arm/imx-common/timer.c文件中定义；
#endif
#ifdef CONFIG_SYS_ALLOC_DPRAM
#if !defined(CONFIG_CPM2)
    dpram_init,
#endif
#endif
    init_baud_rate,     /* initialze baudrate settings 初始化波特率为115200*/
    serial_init,        /* 初始化串口通信设置，在drivers/serial/serial.c文件中定义*/
    console_init_f,     /* 初始化控制台，在common/console.c文件中定义；在zynq中为将gd-&gt;have_console 置1*/
#if defined(CONFIG_BOARD_POSTCLK_INIT)
    board_postclk_init,
#endif
#ifdef CONFIG_FSL_ESDHC
    get_clocks,         //获取了SD卡外设的时钟（sdhc_clk），在arch/arm/imx-common/speed.c文件中定义；
#endif
#ifdef CONFIG_M68K
    get_clocks,
#endif
    env_init,       /* initialize environment 初始化环境变量 准确定义待定*/
#if defined(CONFIG_8xx_CPUCLK_DEFAULT)
    /* get CPU and bus clocks according to the environment variable */
    get_clocks_866,
    /* adjust sdram refresh rate according to the new clock */
    sdram_adjust_866,
    init_timebase,
#endif
     
#ifdef CONFIG_SANDBOX
    sandbox_early_getopt_check,
#endif
#ifdef CONFIG_OF_CONTROL
    fdtdec_prepare_fdt,
#endif
    display_options,    /* say that we are here 打印uboot版本信息和编译信息，在lib/display_options.c文件中定义*/
    display_text_info,  /* show debugging info if required 用来显示CPU信息和主频，在arch/arm/imx-common/cpu.c文件中定义*/
#if defined(CONFIG_MPC8260)
    prt_8260_rsr,
    prt_8260_clks,
#endif /* CONFIG_MPC8260 */
#if defined(CONFIG_MPC83xx)
    prt_83xx_rsr,
#endif
#if defined(CONFIG_PPC) || defined(CONFIG_M68K)
    checkcpu,
#endif
    print_cpuinfo,      /* display cpu info (and speed) 打印cpu信息*/
#if defined(CONFIG_MPC5xxx)
    prt_mpc5xxx_clks,
#endif /* CONFIG_MPC5xxx */
#if defined(CONFIG_DISPLAY_BOARDINFO)
    show_board_info,    /* 打印板级信息 */
#endif
    INIT_FUNC_WATCHDOG_INIT     /* 看门狗初始化 */
#if defined(CONFIG_MISC_INIT_F)
    misc_init_f,
#endif
    INIT_FUNC_WATCHDOG_RESET    /* 重置看门狗 */
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
    init_func_i2c,              /* 初始化i2c */
#endif
#if defined(CONFIG_HARD_SPI)
    init_func_spi,
#endif
    announce_dram_init,         /* DRAM 初始化声明即打印一串字符 */
    /* TODO: unify all these dram functions? */
#if defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32)
    dram_init,      /* configure available RAM banks 设置gd-&gt;ram_size的值 */
#endif
#if defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(CONFIG_M68K)
    init_func_ram,
#endif
#ifdef CONFIG_POST
    post_init_f,
#endif
    INIT_FUNC_WATCHDOG_RESET    /* 重置看门狗 */
#if defined(CONFIG_SYS_DRAM_TEST)
    testdram,
#endif /* CONFIG_SYS_DRAM_TEST */
    INIT_FUNC_WATCHDOG_RESET    /* 重置看门狗 */
#ifdef CONFIG_POST
    init_post,
#endif
    INIT_FUNC_WATCHDOG_RESET    /* 重置看门狗 */
    /*
     * Now that we have DRAM mapped and working, we can
     * relocate the code and continue running from DRAM.
     *
     * Reserve memory at end of RAM for (top down in that order):
     *  - area that won't get touched by U-Boot and Linux (optional)
     *  - kernel log buffer
     *  - protected RAM
     *  - LCD framebuffer
     *  - monitor code
     *  - board info struct
     */
    setup_dest_addr,            /* 更新设置u-boot的入口地址 */
#if defined(CONFIG_BLACKFIN) || defined(CONFIG_NIOS2)
    /* Blackfin u-boot monitor should be on top of the ram */
    reserve_uboot,
#endif
#if defined(CONFIG_LOGBUFFER) &amp;&amp; !defined(CONFIG_ALT_LB_ADDR)
    reserve_logbuffer,
#endif
#ifdef CONFIG_PRAM
    reserve_pram,
#endif
    reserve_round_4k,           /*留出4K大小的环形区域 * /
#if !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF)) &amp;&amp; \
        defined(CONFIG_ARM)
    reserve_mmu,                /* 划分tlb的大小和位置 */
#endif
#ifdef CONFIG_LCD
    reserve_lcd,
#endif
    reserve_trace,
    /* TODO: Why the dependency on CONFIG_8xx? */
#if defined(CONFIG_VIDEO) &amp;&amp; (!defined(CONFIG_PPC) || defined(CONFIG_8xx)) &amp;&amp; \
        !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_X86) &amp;&amp; \
        !defined(CONFIG_BLACKFIN) &amp;&amp; !defined(CONFIG_M68K)
    reserve_video,
#endif
#if !defined(CONFIG_BLACKFIN) &amp;&amp; !defined(CONFIG_NIOS2)
    reserve_uboot,
#endif
#ifndef CONFIG_SPL_BUILD
    reserve_malloc,
    reserve_board,
#endif
    setup_machine,
    reserve_global_data,            /* 划分gd-&gt;data的空间 */
    reserve_fdt,                    /* 划分gd-&gt;fdt的空间 */
    reserve_arch,
    reserve_stacks,                 /* 划分gd-&gt;stack 空间 */
    setup_dram_config,              /* 更新dram的配置，包括首地址和size */
    show_dram_config,               /* dram的配置信息，包括大小，有多少个bank... */
#if defined(CONFIG_PPC) || defined(CONFIG_M68K)
    setup_board_part1,
    INIT_FUNC_WATCHDOG_RESET
    setup_board_part2,
#endif
    display_new_sp,                 /* 给出新的sp指针位置 */
#ifdef CONFIG_SYS_EXTBDINFO
    setup_board_extra,
#endif
    INIT_FUNC_WATCHDOG_RESET        /* 重置看门狗 */
    reloc_fdt,                      /* FDT空间重定位 */
    setup_reloc,                    /* ？？？应该是配置新的reloc空间 */
#if defined(CONFIG_X86) || defined(CONFIG_ARC)
    copy_uboot_to_ram,
    clear_bss,
    do_elf_reloc_fixups,
#endif
#if !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX)
    jump_to_copy,
#endif
    NULL,
};
</code></pre>
<h4>2、_main函数中间部分操作：</h4>
<pre class="notranslate"><code class="notranslate">#if ! defined(CONFIG_SPL_BUILD)
/*
 * Set up intermediate environment (new sp and gd) and call
 * relocate_code(addr_moni). Trick here is that we'll return
 * 'here' but relocated.
 */
    ldr sp, [r9, #GD_START_ADDR_SP] /* sp = gd-&gt;start_addr_sp */
    bic sp, sp, #7  /* 8-byte alignment for ABI compliance */
    ldr r9, [r9, #GD_BD]        /* r9 = gd-&gt;bd */
    sub r9, r9, #GD_SIZE        /* new GD is below bd */
    adr lr, here
    ldr r0, [r9, #GD_RELOC_OFF]     /* r0 = gd-&gt;reloc_off */
    add lr, lr, r0
    ldr r0, [r9, #GD_RELOCADDR]     /* r0 = gd-&gt;relocaddr */
    b   relocate_code
here:
/*
 * now relocate vectors
 */
    bl  relocate_vectors
/* Set up final (full) environment */
    bl  c_runtime_cpu_setup /* we still call old routine here */
#endif
</code></pre>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="left">指令</th>
<th align="left">用法</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">ldmia</td>
<td align="left"><code class="notranslate">r1!, {r10-r11}</code></td>
<td align="left">LDMIA 中的 I 是 increase 的缩写，A 是 after 的缩写，LD加载(load)的意思 R0后面的感叹号“！表示会自动调节 R0里面的指针，<em>ld代表load</em> *其含义是将基址寄存器r1开始的连续2个地址单元的值分别赋给r10,r11，注意的是r0指定的地址每次赋一次r0会加1, * 还有一种是STMDB R1!, {R0,R4-R12} 这就和上面反过来了，ST是存储（store）的意思，D是decrease的意思，B是before的意思，整句话就是R1的存储地址由高到低递减，将R0,R4-R12里的内容存储到R1任务栈里面。</td>
</tr>
<tr>
<td align="left">stmia</td>
<td align="left"><code class="notranslate">r0!, {r10-r11}</code></td>
<td align="left"><em>将寄存器r10到r11的值依次赋值给r0指定的地址单元，每次赋值一次r0就加1</em> st代表store</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<pre class="notranslate"><code class="notranslate">ENTRY(relocate_code)
    ldr r1, =__image_copy_start /* r1 &lt;- SRC &amp;__image_copy_start */
    subs    r4, r0, r1      /* r4 &lt;- relocation offset */
    beq relocate_done       /* skip relocation 和谁比较？？*/
    ldr r2, =__image_copy_end   /* r2 &lt;- SRC &amp;__image_copy_end */
copy_loop:
    ldmia   r1!, {r10-r11}      /* copy from source address [r1]    */
    stmia   r0!, {r10-r11}      /* copy to   target address [r0]    */
    cmp r1, r2          /* until source end address [r2]    */
    blo copy_loop       /* R1 &lt; R2 则执行跳转 */
    /*
     * fix .rel.dyn relocations
     */
    ldr r2, =__rel_dyn_start    /* r2 &lt;- SRC &amp;__rel_dyn_start */
    ldr r3, =__rel_dyn_end  /* r3 &lt;- SRC &amp;__rel_dyn_end */
fixloop:
    ldmia   r2!, {r0-r1}        /* (r0,r1) &lt;- (SRC location,fixup) */
    and r1, r1, #0xff
    cmp r1, #23         /* relative fixup? */
    bne fixnext         /* R1 != #23 则执行跳转到fixnext * /
    /* relative fix: increase location by offset */
    add r0, r0, r4
    ldr r1, [r0]
    add r1, r1, r4
    str r1, [r0]    /* 将r1寄存器的值存到r0中保存的地址 */
fixnext:
    cmp r2, r3
    blo fixloop     /* R2 &lt; R3则执行跳转到fixloop */
relocate_done:
#ifdef __XSCALE__
    /*
     * On xscale, icache must be invalidated and write buffers drained,
     * even with cache disabled - 4.2.7 of xscale core developer's manual
     */
    mcr p15, 0, r0, c7, c7, 0   /* invalidate icache */
    mcr p15, 0, r0, c7, c10, 4  /* drain write buffer */
#endif
    /* ARMv4- don't know bx lr but the assembler fails to see that */
#ifdef __ARM_ARCH_4__
    mov pc, lr
#else
    bx  lr                      /* 子程序返回指令 */
#endif
ENDPROC(relocate_code)
</code></pre>
<p>c_runtime_cpu_setup函数：</p>
<pre class="notranslate"><code class="notranslate">ENTRY(c_runtime_cpu_setup)
/*
 * If I-cache is enabled invalidate it
 */
#ifndef CONFIG_SYS_ICACHE_OFF           /* 宏未定义，直接执行子程序返回指令 */
    mcr p15, 0, r0, c7, c5, 0   @ invalidate icache
    mcr     p15, 0, r0, c7, c10, 4  @ DSB
    mcr     p15, 0, r0, c7, c5, 4   @ ISB
#endif
    bx  lr
ENDPROC(c_runtime_cpu_setup)
</code></pre>
<h4></h4>
<h4>3、后半部分跳转到board_init_r前的操作</h4>
<pre class="notranslate"><code class="notranslate">#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FRAMEWORK)
# ifdef CONFIG_SPL_BUILD
    /* Use a DRAM stack for the rest of SPL, if requested */
    bl  spl_relocate_stack_gd
    cmp r0, #0
    movne   sp, r0
# endif
    ldr r0, =__bss_start    /* this is auto-relocated! */
#ifdef CONFIG_USE_ARCH_MEMSET
    ldr r3, =__bss_end      /* this is auto-relocated! */
    mov r1, #0x00000000     /* prepare zero to clear BSS */
    subs    r2, r3, r0      /* r2 = memset len */
    bl  memset
#else
    ldr r1, =__bss_end      /* this is auto-relocated! 获取bss段尾地址*/
    mov r2, #0x00000000     /* prepare zero to clear BSS 将r2置0*/
clbss_l:
    cmp r0, r1              /* while not at end of BSS 比较r0和r1*/
    strlo r2, [r0]          /* clear 32-bit BSS word 在r0 &lt; R1 时执行将R2寄存器中的数据保存到R0寄存器指向的地址*/
    addlo r0, r0, #4        /* move to next 在r0 &lt; r1时 执行r0+4存到r0中*/
    blo clbss_l             /* R0 &lt; R1时执行跳转到clbss_l
#endif
#if ! defined(CONFIG_SPL_BUILD)
    bl coloured_LED_init
    bl red_led_on
#endif
    /* call board_init_r(gd_t *id, ulong dest_addr) */
    mov     r0, r9                  /* gd_t */
    ldr r1, [r9, #GD_RELOCADDR] /* dest_addr */
    /* call board_init_r */
    ldr pc, =board_init_r   /* this is auto-relocated! PC 更新为board_init_r入口地址，即跳转到函数board_init_r */
    /* we should not return here. */
#endif
ENDPROC(_main)
</code></pre>
<p>在board_init_r中其主要工作在于initcall_run_list(init_sequence_r)</p>
<h5>进一步了解board_init_r，在board_init_r函数中核心部分是执行初始化函数序列 init_sequence_r：</h5>
<pre class="notranslate"><code class="notranslate">init_fnc_t init_sequence_r[] = {
    initr_trace,
    initr_reloc,            //
    /* TODO: could x86/PPC have this also perhaps? */
#ifdef CONFIG_ARM
    initr_caches,           // 初始化cache，使能cache；
#endif
    initr_reloc_global_data,//设置gd-&gt;
#if defined(CONFIG_SYS_INIT_RAM_LOCK) &amp;&amp; defined(CONFIG_E500)
    initr_unlock_ram_in_cache,
#endif
    initr_barrier,
    initr_malloc,           //初始化malloc空间,设置首地址和长度
#ifdef CONFIG_SYS_NONCACHED_MEMORY
    initr_noncached,
#endif
    bootstage_relocate,     //???能看懂但是不确定在干嘛
#ifdef CONFIG_DM
    initr_dm,               //???能看懂但是不确定在干嘛
#endif
#ifdef CONFIG_ARM
    board_init, /* Setup chipselects FEC初始化，在board/freescale/mx6ull_toto/mx6ull_toto.c文件中定义*/
#endif
    /*
     * TODO: printing of the clock inforamtion of the board is now
     * implemented as part of bdinfo command. Currently only support for
     * davinci SOC's is added. Remove this check once all the board
     * implement this.
     */
#ifdef CONFIG_CLOCKS
    set_cpu_clk_info,   /* Setup clock information 设置时钟频率并初始化时钟*/
#endif
    stdio_init_tables,  /* 初始化链表（）*/
    initr_serial,       /* 一系列的初始化操作 */
    initr_announce,     /* 给出gd-&gt;ralocaddr的位置 */
    INIT_FUNC_WATCHDOG_RESET
#ifdef CONFIG_NEEDS_MANUAL_RELOC
    initr_manual_reloc_cmdtable,
#endif
#if defined(CONFIG_PPC) || defined(CONFIG_M68K)
    initr_trap,
#endif
#ifdef CONFIG_ADDR_MAP
    initr_addr_map,
#endif
#if defined(CONFIG_BOARD_EARLY_INIT_R)
    board_early_init_r,
#endif
    INIT_FUNC_WATCHDOG_RESET    /* 看门狗重启 */
#ifdef CONFIG_LOGBUFFER
    initr_logbuffer,
#endif
#ifdef CONFIG_POST
    initr_post_backlog,
#endif
    INIT_FUNC_WATCHDOG_RESET    /* 看门狗重启 */
#ifdef CONFIG_SYS_DELAYED_ICACHE
    initr_icache_enable,
#endif
#if defined(CONFIG_PCI) &amp;&amp; defined(CONFIG_SYS_EARLY_PCI_INIT)
    /*
     * Do early PCI configuration _before_ the flash gets initialised,
     * because PCU ressources are crucial for flash access on some boards.
     */
    initr_pci,
#endif
#ifdef CONFIG_WINBOND_83C553
    initr_w83c553f,
#endif
#ifdef CONFIG_ARCH_EARLY_INIT_R
    arch_early_init_r,
#endif
    power_init_board,           /* 无操作直接返回 */
#ifndef CONFIG_SYS_NO_FLASH
    initr_flash,                /* 初始化flash，具体操作暂未看懂 */
#endif
    INIT_FUNC_WATCHDOG_RESET    /* 看门狗重启 */
#if defined(CONFIG_PPC) || defined(CONFIG_M68K)
    /* initialize higher level parts of CPU like time base and timers */
    cpu_init_r,
#endif
#ifdef CONFIG_PPC
    initr_spi,
#endif
#if defined(CONFIG_X86) &amp;&amp; defined(CONFIG_SPI)
    init_func_spi,
#endif
#ifdef CONFIG_CMD_NAND
    initr_nand,                 /* 初始化nand 没看太懂*/
#endif
#ifdef CONFIG_CMD_ONENAND
    initr_onenand,              /* 初始化nand 没看太懂*/
#endif
#ifdef CONFIG_GENERIC_MMC
    initr_mmc,                  /* 初始化emmc，在common/board_r.c文件中定义 */
#endif
#ifdef CONFIG_HAS_DATAFLASH
    initr_dataflash,
#endif
    initr_env,                  /* 初始化环境变量 */
#ifdef CONFIG_SYS_BOOTPARAMS_LEN
    initr_malloc_bootparams,
#endif
    INIT_FUNC_WATCHDOG_RESET    /* 看门狗重启 */
    initr_secondary_cpu,        /* 无具体操作 直接返回*/
#ifdef CONFIG_SC3
    initr_sc3_read_eeprom,
#endif
#if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)
    mac_read_from_eeprom,
#endif
    INIT_FUNC_WATCHDOG_RESET
#if defined(CONFIG_PCI) &amp;&amp; !defined(CONFIG_SYS_EARLY_PCI_INIT)
    /*
     * Do pci configuration
     */
    initr_pci,
#endif
    stdio_add_devices,          /* stdio_add_devices执行stdio设备的注册。stdio设备层工作在serail层之上，但stdio设备并不限于serial设备，比如标准输出设备可能包括显示器 */
                                /* 包括i2c_init_call 、drv_system_init和serial_stdio_init
                                /* serial设备到stdio的注册通过函数serial_stdio_ini来实现，其在drivres/serial/serial.c中定义
                                /* 用i2c_set_bus_num()函数去将i2c切换到需要的总线上 */
                                /* 调用drv_system_init ()注册串口设备到设备列表中 */
    initr_jumptable,            /* 给gd-&gt;jt赋值 */
#ifdef CONFIG_API
    initr_api,                  /* 初始化u-boot下的部分api 好像和命令相关  */
#endif
    console_init_r,     /* fully init console as a device 初始化控制台，在common/console.c文件中定义 */
#ifdef CONFIG_DISPLAY_BOARDINFO_LATE
    show_board_info,    /* 给出板级信息相关 Xilinx Zynq */
#endif
#ifdef CONFIG_ARCH_MISC_INIT
    arch_misc_init,     /* miscellaneous arch-dependent init */
#endif
#ifdef CONFIG_MISC_INIT_R
    misc_init_r,        /* miscellaneous platform-dependent init */
#endif
    INIT_FUNC_WATCHDOG_RESET
#ifdef CONFIG_CMD_KGDB
    initr_kgdb,
#endif
    interrupt_init,                 /* 初始化中断 在arch/arm/lib/interrupts.c文件中定义*/
#if defined(CONFIG_ARM) || defined(CONFIG_AVR32)
    initr_enable_interrupts,        /* 使能中断 在arch/arm/lib/interrupts.c文件中定义*/
#endif
#if defined(CONFIG_X86) || defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32) \
    || defined(CONFIG_M68K)
    timer_init,     /* initialize timer */
#endif
#if defined(CONFIG_STATUS_LED) &amp;&amp; defined(STATUS_LED_BOOT)
    initr_status_led,               /* 初始化led状态灯 */
#endif
    /* PPC has a udelay(20) here dating from 2002. Why? */
#ifdef CONFIG_CMD_NET
    initr_ethaddr,                  /* 初始化网络地址，获取MAC地址，读取环境变量ethaddr的值 */
#endif
#ifdef CONFIG_BOARD_LATE_INIT
    board_late_init,                /* Get the bootmode register value 获取boot方式寄存器值将其保存到环境变量中 */
#endif
#ifdef CONFIG_CMD_SCSI
    INIT_FUNC_WATCHDOG_RESET
    initr_scsi,                     /* 实际运行函数所在的宏未定义 */
#endif
#ifdef CONFIG_CMD_DOC
    INIT_FUNC_WATCHDOG_RESET
    initr_doc,                      /* 未知待定 */
#endif
#ifdef CONFIG_BITBANGMII
    initr_bbmii,
#endif
#ifdef CONFIG_CMD_NET
    INIT_FUNC_WATCHDOG_RESET
    initr_net,                      /* 初始化网络设备，函 数 调 用 顺 序 为 ：initr_net-&gt;eth_initialize-&gt;board_eth_init()，在common/board_r.c文件中定义 */
#endif
#ifdef CONFIG_POST
    initr_post,
#endif
#if defined(CONFIG_CMD_PCMCIA) &amp;&amp; !defined(CONFIG_CMD_IDE)
    initr_pcmcia,
#endif
#if defined(CONFIG_CMD_IDE)
    initr_ide,                      /* 初始化ide，并打印出ide相关信息 */
#endif
#ifdef CONFIG_LAST_STAGE_INIT
    INIT_FUNC_WATCHDOG_RESET
    /*
     * Some parts can be only initialized if all others (like
     * Interrupts) are up and running (i.e. the PC-style ISA
     * keyboard).
     */
    last_stage_init,
#endif
#ifdef CONFIG_CMD_BEDBUG
    INIT_FUNC_WATCHDOG_RESET
    initr_bedbug,                   /* 实际语句被未定义宏限制，当前为直接返回 */
#endif
#if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
    initr_mem,
#endif
#ifdef CONFIG_PS2KBD
    initr_kbd,
#endif
    run_main_loop,                  /* 主循环，处理命令 */
};
</code></pre>
<h4>4、run_main_loop</h4>
<p>uboot启动以后会进入3秒倒计时，如果在3秒倒计时结束之前按下按下回车键，那么就会进入uboot的命令模式，如果倒计时结束以后都没有按下回车键，那么就会自动启动Linux内核，这个功能就是由run_main_loop函数来完成的。</p>
<pre class="notranslate"><code class="notranslate">static int run_main_loop(void)
{
    /* main_loop() can return to retry autoboot, if so just run it again */
    for (;;)
        main_loop();
    return 0;
}
</code></pre>
<h5>main_loop函数定义：</h5>
<pre class="notranslate"><code class="notranslate">void main_loop(void)
{
    const char *s;
    bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");         /* 调用bootstage_mark_name函数，打印出启动进度 */
    modem_init();
    cli_init();                                                         /* cli_init函数，初始化hushshell相关的变量 */
    run_preboot_environment_command();
    s = bootdelay_process();                                            /* 此函数会读取环境变量bootdelay和bootcmd的内容，然后将bootdelay的值赋值给全局变量stored_bootdelay，返回值为环境变量bootcmd的值*/
    if (cli_process_fdt(&amp;s))                                           
        cli_secure_boot_cmd(s);
    autoboot_command(s);                                                /* autoboot_command函数，此函数就是检查倒计时是否结束？倒计时结束之前有没有被打断？在文件common/autoboot.c文件中定义，具体代码如下 */
    cli_loop();                                                         /* 死循环，处理在ctrl + u打断情况下用户输入的命令 */
}
</code></pre>
<p>u-boot启动到启动内核的程序调用在 autoboot_command函数中倒计时结束不按下所执行的语句中</p>
<pre class="notranslate"><code class="notranslate">void autoboot_command(const char *s)
{
    debug("### main_loop: bootcmd=\"%s\"\n", s ? s : "&lt;UNDEFINED&gt;");
    if (stored_bootdelay != -1 &amp;&amp; s &amp;&amp; !abortboot(stored_bootdelay)) {      /* 按下则不执行if{}里面的语句直接结束本函数，不按下则执行if{}里的语句
        printf("no press any key\n");
        auto_net_upgrade();
        run_command_list(s, -1, 0);
    }
}
</code></pre>
<p>其中延时按下相关的函数在abortboot</p>
<pre class="notranslate"><code class="notranslate">static int abortboot(int bootdelay)
{
    return abortboot_normal(bootdelay);
}
 
static int abortboot_normal(int bootdelay)
{
    int abort = 0;
    unsigned long ts;
    int hit_cnt = 0;
    if (bootdelay &gt;= 0)
        printf("Hit %d times Ctrl+u to stop autoboot: %2d ", MAX_HIT_KEY_CNT, bootdelay);
 
    while ((bootdelay &gt; 0) &amp;&amp; (!abort)) {
        --bootdelay;
        /* delay 1000 ms */
        ts = get_timer(0);
        do {
            if (tstc()) {   /* we got a key press   */
                int c = getc();
                if (c == 0x15) {
                    hit_cnt++;
                } else {
                    hit_cnt = 0;
                }
                 
                if (hit_cnt &gt;= MAX_HIT_KEY_CNT) {
                    abort  = 1; /* don't auto boot  */
                    bootdelay = 0;  /* no more delay    */
                    break;
                }
            }
            udelay(1000);
        } while (!abort &amp;&amp; get_timer(ts) &lt; 1000);
        printf("\b\b\b%2d ", bootdelay);
    }
    putc('\n');
    return abort;
}
</code></pre>
<p>如果在倒计时结束前按下ctrl + u 则执行：cli_loop();</p>
<pre class="notranslate"><code class="notranslate">void cli_loop(void)
{
    parse_file_outer();             /*
    /* This point is never reached */
    for (;;);
}
</code></pre>
<p>如果知道倒计时结束也不按下则执行：</p>
<pre class="notranslate"><code class="notranslate">auto_net_upgrade();
run_command_list(s, -1, 0);
</code></pre></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://nobody-ZWQ.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","nobody-ZWQ/nobody-ZWQ.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
