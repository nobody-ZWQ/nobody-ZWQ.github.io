<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://nobody-ZWQ.github.io</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://nobody-ZWQ.github.io</link></image><lastBuildDate>Sat, 20 Sep 2025 14:02:47 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>基础知识——spi</title><link>https://nobody-ZWQ.github.io/post/ji-chu-zhi-shi-%E2%80%94%E2%80%94spi.html</link><guid isPermaLink="true">https://nobody-ZWQ.github.io/post/ji-chu-zhi-shi-%E2%80%94%E2%80%94spi.html</guid><pubDate>Sat, 20 Sep 2025 14:02:20 +0000</pubDate></item><item><title>基础知识——i2c</title><link>https://nobody-ZWQ.github.io/post/ji-chu-zhi-shi-%E2%80%94%E2%80%94i2c.html</link><guid isPermaLink="true">https://nobody-ZWQ.github.io/post/ji-chu-zhi-shi-%E2%80%94%E2%80%94i2c.html</guid><pubDate>Sat, 20 Sep 2025 13:56:42 +0000</pubDate></item><item><title>面经总结</title><link>https://nobody-ZWQ.github.io/post/mian-jing-zong-jie.html</link><description>**linux system部分**（技术深度）

1、中断下半部有哪些方式实现
2、内核进程和用户进程的区别
3、函数多层嵌套调用情况下其参数是如何传递的；编译的优化等级会对这些造成什么样的影响
4、CPU中断的执行过程

**总线部分**（基础夯实）

1、I2C 信号的基本类型及识别；i2c设备如何挂到i2c线上去的，i2c通信所用到的接口有哪些（内核下），通信异常一般有些情况，一般往哪些方向去考虑。</description><guid isPermaLink="true">https://nobody-ZWQ.github.io/post/mian-jing-zong-jie.html</guid><pubDate>Sat, 20 Sep 2025 13:45:15 +0000</pubDate></item><item><title>安全启动secure_boot</title><link>https://nobody-ZWQ.github.io/post/an-quan-qi-dong-secure_boot.html</link><guid isPermaLink="true">https://nobody-ZWQ.github.io/post/an-quan-qi-dong-secure_boot.html</guid><pubDate>Thu, 18 Sep 2025 17:29:58 +0000</pubDate></item><item><title>ARM linux启动流程</title><link>https://nobody-ZWQ.github.io/post/ARM%20linux-qi-dong-liu-cheng.html</link><description># BootROM

此程序出厂固化在soc内部rom中，soc上电首先执行，主要作用：

1. 初始化时钟、SRAM
2. 根据寄存器选择启动介质
3. 从启动介质搬运loader到SRAM执行

# Loader

由于SRAM一般较小，所以loader体积较小，主要完成以下功能：

1. 初始化DRAM
2. 搬运U-Boot代码到DRAM执行

# U-Boot

U-Boot启动以重定位（relocate）操作分成两个阶段

1. 重定位前（board_init_f）：只做必要的初始化，soc、时钟、DRAM、串口
2. 重定位（relocate）：将自身搬移到DRAM的末尾地址执行
3. 重定位后（board_init_r）：初始化需要的外设（存储、网络等），命令行系统，引导内核

# Kernel

1. 解析命令行参数
2. initcall各类驱动初始化
3. 挂载根文件系统
4. 启动init进程，进入用户空间。</description><guid isPermaLink="true">https://nobody-ZWQ.github.io/post/ARM%20linux-qi-dong-liu-cheng.html</guid><pubDate>Thu, 18 Sep 2025 17:23:38 +0000</pubDate></item><item><title>u-boot启动流程之 abortboot未按下ctrl+u</title><link>https://nobody-ZWQ.github.io/post/u-boot-qi-dong-liu-cheng-zhi-%20abortboot-wei-an-xia-ctrl%2Bu.html</link><description>## 1、起初在cli.c调用

```
|--&gt;auto_net_upgrade(u-boot/common/autoboot.c)
|--&gt;run_command_list(u-boot/common/cli.c)
    |--&gt;parse_string_outer(u-boot/common/cli_hush.c)
        |--&gt;setup_string_in_str(u-boot/common/cli_hush.c)
        |--&gt;parse_stream_outer(u-boot/common/cli_hush.c)
            |--&gt;initialize_context(u-boot/common/cli_hush.c)
            |--&gt;update_ifs_map(u-boot/common/cli_hush.c)
            |--&gt;parse_stream(u-boot/common/cli_hush.c)
            |--&gt;run_list(u-boot/common/cli_hush.c)
                |--&gt;run_list_real(u-boot/common/cli_hush.c)
                    |--&gt;make_list_in(u-boot/common/cli_hush.c)
                    |--&gt;run_pipe_real(u-boot/common/cli_hush.c)
                        |--&gt;cmd_process(u-boot/common/command.c)
                            |--&gt;find_cmd(u-boot/common/command.c)
                            |--&gt;cmd_call(u-boot/common/command.c)
                                |--&gt;do_bootz(u-boot/common/cmd_bootm.c)
                                    |--&gt;
                |--&gt;free_pipe_list(u-boot/common/cli_hush.c)
```

## 2、进入cli_hush.c中的parse_string_outer

### parse_string_outer函数定义

```
int parse_string_outer(const char *s, int flag)
{
    struct in_str input;
    char *p = NULL;
    int rcode;
    if (!s)
        return 1;
    if (!*s)
        return 0;
    if (!(p = strchr(s, '\n')) || *++p) {
        p = xmalloc(strlen(s) + 2);
        strcpy(p, s);
        strcat(p, '\n');
        setup_string_in_str(&amp;input, p);
        rcode = parse_stream_outer(&amp;input, flag);
        free(p);
        return rcode;
    } else {
    setup_string_in_str(&amp;input, s);
    return parse_stream_outer(&amp;input, flag);
    }
}
```

### parse_stream_outer函数定义

```
static int parse_stream_outer(struct in_str *inp, int flag)
{
    struct p_context ctx;
    o_string temp=NULL_O_STRING;
    int rcode;
    int code = 1;
    do {
        ctx.type = flag;
        initialize_context(&amp;ctx);
        update_ifs_map();
        if (!(flag &amp; FLAG_PARSE_SEMICOLON) || (flag &amp; FLAG_REPARSING)) mapset((uchar *)';$&amp;|', 0);
        inp-&gt;promptmode=1;
        rcode = parse_stream(&amp;temp, &amp;ctx, inp,
                     flag &amp; FLAG_CONT_ON_NEWLINE ? -1 : '\n');
        if (rcode == 1) flag_repeat = 0;
        if (rcode != 1 &amp;&amp; ctx.old_flag != 0) {
            syntax();
            flag_repeat = 0;
        }
        if (rcode != 1 &amp;&amp; ctx.old_flag == 0) {
            done_word(&amp;temp, &amp;ctx);
            done_pipe(&amp;ctx,PIPE_SEQ);
            code = run_list(ctx.list_head);
            if (code == -2) {   /* exit */
                b_free(&amp;temp);
                code = 0;
                /* XXX hackish way to not allow exit from main loop */
                if (inp-&gt;peek == file_peek) {
                    printf('exit not allowed from main input shell.\n');
                    continue;
                }
                break;
            }
            if (code == -1)
                flag_repeat = 0;
        } else {
            if (ctx.old_flag != 0) {
                free(ctx.stack);
                b_reset(&amp;temp);
            }
            if (inp-&gt;__promptme == 0) printf('&lt;INTERRUPT&gt;\n');
            inp-&gt;__promptme = 1;
            temp.nonnull = 0;
            temp.quote = 0;
            inp-&gt;p = NULL;
            free_pipe_list(ctx.list_head,0);
        }
        b_free(&amp;temp);
    /* loop on syntax errors, return on EOF */
    } while (rcode != -1 &amp;&amp; !(flag &amp; FLAG_EXIT_FROM_LOOP) &amp;&amp;
        (inp-&gt;peek != static_peek || b_peek(inp)));
    return (code != 0) ? 1 : 0;
}
```



### run_list_real函数定义

```
static int run_list_real(struct pipe *pi)
{
    char *save_name = NULL;
    char **list = NULL;
    char **save_list = NULL;
    struct pipe *rpipe;
    int flag_rep = 0;
    int rcode=0, flag_skip=1;
    int flag_restore = 0;
    int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
    reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
    /* check syntax for 'for' */
    for (rpipe = pi; rpipe; rpipe = rpipe-&gt;next) {
        if ((rpipe-&gt;r_mode == RES_IN ||
            rpipe-&gt;r_mode == RES_FOR) &amp;&amp;
            (rpipe-&gt;next == NULL)) {
                syntax();
#ifdef __U_BOOT__
                flag_repeat = 0;
#endif
                return 1;
        }
        if ((rpipe-&gt;r_mode == RES_IN &amp;&amp;
            (rpipe-&gt;next-&gt;r_mode == RES_IN &amp;&amp;
            rpipe-&gt;next-&gt;progs-&gt;argv != NULL))||
            (rpipe-&gt;r_mode == RES_FOR &amp;&amp;
            rpipe-&gt;next-&gt;r_mode != RES_IN)) {
                syntax();
#ifdef __U_BOOT__
                flag_repeat = 0;
#endif
                return 1;
        }
    }
    for (; pi; pi = (flag_restore != 0) ? rpipe : pi-&gt;next) {
        if (pi-&gt;r_mode == RES_WHILE || pi-&gt;r_mode == RES_UNTIL ||
            pi-&gt;r_mode == RES_FOR) {
#ifdef __U_BOOT__
                /* check Ctrl-C */
                ctrlc();
                if ((had_ctrlc())) {
                    return 1;
                }
#endif
                flag_restore = 0;
                if (!rpipe) {
                    flag_rep = 0;
                    rpipe = pi;
                }
        }
        rmode = pi-&gt;r_mode;
        debug_printf('rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n', rmode, if_code, next_if_code, skip_more_in_this_rmode);
        if (rmode == skip_more_in_this_rmode &amp;&amp; flag_skip) {
            if (pi-&gt;followup == PIPE_SEQ) flag_skip=0;
            continue;
        }
        flag_skip = 1;
        skip_more_in_this_rmode = RES_XXXX;
        if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
        if (rmode == RES_THEN &amp;&amp;  if_code) continue;
        if (rmode == RES_ELSE &amp;&amp; !if_code) continue;
        if (rmode == RES_ELIF &amp;&amp; !if_code) break;
        if (rmode == RES_FOR &amp;&amp; pi-&gt;num_progs) {
            if (!list) {
                /* if no variable values after 'in' we skip 'for' */
                if (!pi-&gt;next-&gt;progs-&gt;argv) continue;
                /* create list of variable values */
                list = make_list_in(pi-&gt;next-&gt;progs-&gt;argv,
                    pi-&gt;progs-&gt;argv[0]);
                save_list = list;
                save_name = pi-&gt;progs-&gt;argv[0];
                pi-&gt;progs-&gt;argv[0] = NULL;
                flag_rep = 1;
            }
            if (!(*list)) {
                free(pi-&gt;progs-&gt;argv[0]);
                free(save_list);
                list = NULL;
                flag_rep = 0;
                pi-&gt;progs-&gt;argv[0] = save_name;
                continue;
            } else {
                /* insert new value from list for variable */
                if (pi-&gt;progs-&gt;argv[0])
                    free(pi-&gt;progs-&gt;argv[0]);
                pi-&gt;progs-&gt;argv[0] = *list++;
            }
        }
        if (rmode == RES_IN) continue;
        if (rmode == RES_DO) {
            if (!flag_rep) continue;
        }
        if (rmode == RES_DONE) {
            if (flag_rep) {
                flag_restore = 1;
            } else {
                rpipe = NULL;
            }
        }
        if (pi-&gt;num_progs == 0) continue;
        rcode = run_pipe_real(pi);
        debug_printf('run_pipe_real returned %d\n',rcode);
        if (rcode &lt; -1) {
            last_return_code = -rcode - 2;
            return -2;  /* exit */
        }
        last_return_code=(rcode == 0) ? 0 : 1;
        if ( rmode == RES_IF || rmode == RES_ELIF )
            next_if_code=rcode;  /* can be overwritten a number of times */
        if (rmode == RES_WHILE)
            flag_rep = !last_return_code;
        if (rmode == RES_UNTIL)
            flag_rep = last_return_code;
        if ( (rcode==EXIT_SUCCESS &amp;&amp; pi-&gt;followup==PIPE_OR) ||
             (rcode!=EXIT_SUCCESS &amp;&amp; pi-&gt;followup==PIPE_AND) )
            skip_more_in_this_rmode=rmode;
    }
    return rcode;
}
```



### run_pipe_real函数实际运行部分：

```
static int run_pipe_real(struct pipe *pi)
{
    int i;
    int nextin;
    int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
    struct child_prog *child;
    char *p;
    nextin = 0;
    if (pi-&gt;num_progs == 1) child = &amp; (pi-&gt;progs[0]);
     
    if (pi-&gt;num_progs == 1 &amp;&amp; pi-&gt;progs[0].argv != NULL) {
        for (i=0; is_assignment(child-&gt;argv[i]); i++) { /* nothing */ }
        for (i = 0; is_assignment(child-&gt;argv[i]); i++) {
            p = insert_var_value(child-&gt;argv[i]);
            set_local_var(p, 0);
            if (p != child-&gt;argv[i]) {
                child-&gt;sp--;
                free(p);
            }
        }
        /* Process the command */
        return cmd_process(flag, child-&gt;argc, child-&gt;argv,
                   &amp;flag_repeat, NULL);
    }
}
```

## 3、进入到command.c中的cmd_process

### cmd_process 函数实际运行部分

```
enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
                   int *repeatable, ulong *ticks)
{
    enum command_ret_t rc = CMD_RET_SUCCESS;
    cmd_tbl_t *cmdtp;
    /* Look up command in command table */
    cmdtp = find_cmd(argv[0]);                  //初始的cmd也就是argv[0]在经过find_cmd函数后将得到cmd相关的函数；其过程暂不清楚
                                                //例：此处的argv[0]是booz，经过find_cmd后得到cmdtp-&gt;cmd为do_bootz
    /* found - check max args */
    if (argc &gt; cmdtp-&gt;maxargs)
        rc = CMD_RET_USAGE;
    /* avoid 'bootd' recursion */
    if (cmdtp-&gt;cmd == do_bootd) {
        if (flag &amp; CMD_FLAG_BOOTD) {
            puts(''bootd' recursion detected\n');
            rc = CMD_RET_FAILURE;
        } else {
            flag |= CMD_FLAG_BOOTD;
        }
    }
    /* If OK so far, then do the command */
    if (!rc) {
        if (ticks)
            *ticks = get_timer(0);
        rc = cmd_call(cmdtp, flag, argc, argv); //cmd相关的函数do_bootz是在此函数中执行的
        if (ticks)
            *ticks = get_timer(*ticks);
        *repeatable &amp;= cmdtp-&gt;repeatable;
    }
    if (rc == CMD_RET_USAGE)
        rc = cmd_usage(cmdtp);
    return rc;
}
```

### find_cmd函数实际执行：

```
#define ll_entry_start(_type, _list)                    \
({                                  \
    static char start[0] __aligned(4) __attribute__((unused,    \
        section('.u_boot_list_2_'#_list'_1')));         \
    (_type *)&amp;start;                        \
})
 
#define ll_entry_end(_type, _list)                  \
({                                  \
    static char end[0] __aligned(4) __attribute__((unused,  \
        section('.u_boot_list_2_'#_list'_3')));         \
    (_type *)&amp;end;                          \
})
 
#define ll_entry_count(_type, _list)                    \
    ({                              \
        _type *start = ll_entry_start(_type, _list);        \
        _type *end = ll_entry_end(_type, _list);        \
        unsigned int _ll_result = end - start;          \
        _ll_result;                     \
    })
 
cmd_tbl_t *find_cmd_tbl(const char *cmd, cmd_tbl_t *table, int table_len)
{
    cmd_tbl_t *cmdtp;
    cmd_tbl_t *cmdtp_temp = table;  /* Init value */
    const char *p;
    int len;
    int n_found = 0;
    if (!cmd)
        return NULL;
    /*
     * Some commands allow length modifiers (like 'cp.b');
     * compare command name only until first dot.
     */
    len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
    for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {
        if (strncmp(cmd, cmdtp-&gt;name, len) == 0) {
            if (len == strlen(cmdtp-&gt;name))
                return cmdtp;   /* full match */
            cmdtp_temp = cmdtp; /* abbreviated command ? */
            n_found++;
        }
    }
    if (n_found == 1) {         /* exactly one match */
        return cmdtp_temp;
    }
    return NULL;    /* not found or ambiguous command */
}
 
cmd_tbl_t *find_cmd(const char *cmd)
{
    cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);
    const int len = ll_entry_count(cmd_tbl_t, cmd);
    return find_cmd_tbl(cmd, start, len);
}
```

### cmd_call函数实际执行：

```
static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
    int result;
    result = (cmdtp-&gt;cmd)(cmdtp, flag, argc, argv);      //do_bootz函数在此调用执行
    if (result)
        debug('Command failed, result=%d', result);
    return result;
}
```

## 4、进入到cmd_bootm函数中的do_bootz

### do_bootz函数实际执行：

```
int do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
    int ret;
    /* Consume 'bootz' 此时的argc是4，表示4个参数，同时argv[0]是bootz*/  
    argc--; argv++;     //此时argc是3，还有3个参数，同时argv[0]是bootz引导内核的地址0x2080000
    if (bootz_start(cmdtp, flag, argc, argv, &amp;images))          //images当前还只是个空的结构体实例
        return 1;
    /*
     * We are doing the BOOTM_STATE_LOADOS state ourselves, so must
     * disable interrupts ourselves
     */
    bootm_disable_interrupts();
    images.os.os = IH_OS_LINUX;
    ret = do_bootm_states(cmdtp, flag, argc, argv,
                  BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
                  BOOTM_STATE_OS_GO,
                  &amp;images, 1);
    return ret;
}
```

### 1、bootz_start函数实际执行：

```
static int bootz_start(cmd_tbl_t *cmdtp, int flag, int argc,
            char * const argv[], bootm_headers_t *images)
{
    int ret;
    ulong zi_start, zi_end;
    ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START,
                  images, 1);
    /* Setup Linux kernel zImage entry point */
    if (!argc) {
        images-&gt;ep = load_addr;
        debug('*  kernel: default image load address = 0x%08lx\n',
                load_addr);
    } else {
        images-&gt;ep = simple_strtoul(argv[0], NULL, 16);
        debug('*  kernel: cmdline image address = 0x%08lx\n',
            images-&gt;ep);
    }
    printf('images-ep %x\n', images-&gt;ep);
    ret = bootz_setup(images-&gt;ep, &amp;zi_start, &amp;zi_end);
    if (ret != 0)
        return 1;
    lmb_reserve(&amp;images-&gt;lmb, images-&gt;ep, zi_end - zi_start);
    /*
     * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not
     * have a header that provide this informaiton.
     */
    if (bootm_find_ramdisk_fdt(flag, argc, argv))
        return 1;
    return 0;
}
```

### do_bootm_states函数定义

```
 int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
            int states, bootm_headers_t *images, int boot_progress)
{
    boot_os_fn *boot_fn;
    ulong iflag = 0;
    int ret = 0, need_boot_fn;
    images-&gt;state |= states;
    /*
     * Work through the states and see how far we get. We stop on
     * any error.
     */
    if (states &amp; BOOTM_STATE_START)                     //states=1,ret=0;BOOTM_STATE_START=(0x00000001);
        ret = bootm_start(cmdtp, flag, argc, argv);     //在本函数中唯二需要正常执行的函数之一
    if (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))          //states=1,ret=0;BOOTM_STATE_FINDOS=(0x00000002);
        ret = bootm_find_os(cmdtp, flag, argc, argv);  
    if (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER)) {     //states=1,ret=0;BOOTM_STATE_FINDOTHER=(0x00000004);
        ret = bootm_find_other(cmdtp, flag, argc, argv);
        argc = 0;   /* consume the args */
    }
    /* From now on, we need the OS boot function */     //此时states=1,ret=0;
    if (ret)
        return ret;
    boot_fn = bootm_os_get_boot_func(images-&gt;os.os); //在本函数中唯二需要正常执行的函数之一
    need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE |
            BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |
            BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);        //这部分的宏0x00000 7E 0
    /* Call various other states that are not generally used */ //此时boot_fn = NULL,need_boot_fn = 0x700
    if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_CMDLINE))              //states=1,ret=0;BOOTM_STATE_OS_CMDLINE=(0x00000040);
        ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);
    if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_BD_T))                 //states=1,ret=0;BOOTM_STATE_OS_BD_T=(0x00000080);
        ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images);
    if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP))                 //states=1,ret=0;BOOTM_STATE_OS_PREP=(0x00000100);
        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);
    /* Check for unsupported subcommand. */
    if (ret) {
        puts('subcommand not supported\n');
        return ret;
    }
    /* Now run the OS! We hope this doesn't return */
    if (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))                   //ret =0;states =1;BOOTM_STATE_OS_GO=0x00000400;
        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,
                images, boot_fn);
    /* Deal with any fallout */
err:
    if (iflag)                                          //iflag= 0;ret =0;
        enable_interrupts();
    if (ret == BOOTM_ERR_UNIMPLEMENTED)
        bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);
    else if (ret == BOOTM_ERR_RESET)
        do_reset(cmdtp, flag, argc, argv);
    return ret;
}
```

#### bootm_start函数定义实际执行：

```
static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc,
               char * const argv[])
{
    memset((void *)&amp;images, 0, sizeof(images));
    images.verify = getenv_yesno('verify');       //从环境变量中获取verify的值
    boot_start_lmb(&amp;images);
    bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, 'bootm_start');
    images.state = BOOTM_STATE_START;
    return 0;
}
```

#### 1、getenv_yesno函数定义 实际执行：

```
char *getenv(const char *name)
{
    if (gd-&gt;flags &amp; GD_FLG_ENV_READY) { /* after import into hashtable */
        ENTRY e, *ep;
        WATCHDOG_RESET();
        e.key   = name;                         //将需要查找的变量转为ENTRY结构体变量的键值
        e.data  = NULL;
        hsearch_r(e, FIND, &amp;ep, &amp;env_htab, 0);
        return ep ? ep-&gt;data : NULL;
    }
    /* restricted capabilities before import */
    if (getenv_f(name, (char *)(gd-&gt;env_buf), sizeof(gd-&gt;env_buf)) &gt; 0)
        return (char *)(gd-&gt;env_buf);
    return NULL;
}
int getenv_yesno(const char *var)
{
    char *s = getenv(var);
    if (s == NULL)
        return -1;
    return (*s == '1' || *s == 'y' || *s == 'Y' || *s == 't' || *s == 'T') ?
        1 : 0;
}
```

getenv函数定义：

本函数涉及到env变量的相关修改，实际解析暂未完成，仅仅初步完成hsearch_r函数的理解（），getenc_f函数的理解分析暂未完成因为好像很多地方均有相关的调用导致打印信息比较杂不好确定

hsearch_r函数定义

```
int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
          struct hsearch_data *htab, int flag)
{
    unsigned int hval;
    unsigned int count;
    unsigned int len = strlen(item.key);
    unsigned int idx;
    unsigned int first_deleted = 0;
    int ret;
    /* Compute an value for the given string. Perhaps use a better method. */
    hval = len;
    count = len;
    //hash表键值生成算法:
    //将item.key---环境变量name中的字符移位并累加，然后模hash表项数，即为该环境变量在hash表项中的数组索引---hash表键值。</description><guid isPermaLink="true">https://nobody-ZWQ.github.io/post/u-boot-qi-dong-liu-cheng-zhi-%20abortboot-wei-an-xia-ctrl%2Bu.html</guid><pubDate>Thu, 18 Sep 2025 17:20:55 +0000</pubDate></item><item><title>u-boot启动流程之 abortboot按下ctrl+u</title><link>https://nobody-ZWQ.github.io/post/u-boot-qi-dong-liu-cheng-zhi-%20abortboot-an-xia-ctrl%2Bu.html</link><description>### **代码调用跟踪**
```
u-boot.lds:(arch/arm/cpu/u-boot.lds)
    |--&gt;_start:(arch/arm/lib/vectors.S)
        |--&gt;reset(arch/arm/cpu/armv7/start.S)   
            |--&gt;save_boot_params(arch/arm/cpu/armv7/start.S)/*将引导参数保存到内存中*/
                |--&gt;save_boot_params_ret(arch/arm/cpu/armv7/start.S)
                    |--&gt;cpu_init_cp15(arch/arm/cpu/armv7/start.S)/*初始化*/
                    |--&gt;cpu_init_crit(arch/arm/cpu/armv7/start.S)
                        |--&gt;lowlevel_init(arch/arm/cpu/armv7/lowlevel_init.S)
                    |--&gt;_main(arch/arm/lib/crt0.S)
                        |--&gt;board_init_f_alloc_reserve(common/init/board_init.c)/*为u-boot的gd结构体分配空间*/
                        |--&gt;board_init_f_init_reserve(common/init/board_init.c)    /*将gd结构体清零*/
                        |--&gt;board_init_f(common/board_f.c)
                            |--&gt;initcall_run_list(include/initcall.h)    /*初始化序列函数*/
                                |--&gt;init_sequence_f[](common/board_f.c)    /* 初始化序列函数数组 */
                                    |--&gt;board_early_init_f(board/freescale/mx6ull_toto/mx6ull_toto.c)/*初始化串口的IO配置*/
                                    |--&gt;timer_init(arch/arm/imx-common/timer.c)    /*初始化内核定时器，为uboot提供时钟节拍*/
                                    |--&gt;init_baud_rate(common/board_f.c)        /*初始化波特率*/
                                    |--&gt;serial_init(drivers/serial/serial.c)    /*初始化串口通信设置*/
                                    |--&gt;console_init_f(common/console.c)        /*初始化控制台*/
                                    |--&gt;...
                        |--&gt;relocate_code(arch/arm/lib/relocate.S)    /*主要完成镜像拷贝和重定位*/
                        |--&gt;relocate_vectors(arch/arm/lib/relocate.S)/*重定位向量表*/
                        |--&gt;board_init_r(common/board_r.c)/*板级初始化*/
                            |--&gt;initcall_run_list(include/initcall.h)/*初始化序列函数*/
                                |--&gt;init_sequence_r[](common/board_f.c)/*序列函数*/
                                    |--&gt;initr_reloc(common/board_r.c)    /*设置 gd-&gt;flags,标记重定位完成*/
                                    |--&gt;serial_initialize(drivers/serial/serial-uclass.c)/*初始化串口*/
                                        |--&gt;serial_init(drivers/serial/serial-uclass.c)     /*初始化串口*/
                                    |--&gt;initr_mmc(common/board_r.c)                         /*初始化emmc*/
                                        |--&gt;mmc_initialize(drivers/mmc/mmc.c)
                                            |--&gt;mmc_do_preinit(drivers/mmc/mmc.c)
                                                |--&gt;mmc_start_init(drivers/mmc/mmc.c)
                                    |--&gt;console_init_r(common/console.c)                /*初始化控制台*/
                                    |--&gt;interrupt_init(arch/arm/lib/interrupts.c)        /*初始化中断*/
                                    |--&gt;initr_net(common/board_r.c)                        /*初始化网络设备*/
                                        |--&gt;eth_initialize(net/eth-uclass.c)
                                            |--&gt;eth_common_init(net/eth_common.c)
                                                |--&gt;phy_init(drivers/net/phy/phy.c)
                                            |--&gt;uclass_first_device_check(drivers/core/uclass.c)
                                                |--&gt;uclass_find_first_device(drivers/core/uclass.c)
                                                |--&gt;device_probe(drivers/core/device.c)
                                                    |--&gt;device_of_to_plat(drivers/core/device.c)
                                                        |--&gt;drv-&gt;of_to_plat
                                                            |--&gt;fecmxc_of_to_plat(drivers/net/fec_mxc.c)/*解析设备树信息*/
                                                    |--&gt;device_get_uclass_id(drivers/core/device.c)
                                                    |--&gt;uclass_pre_probe_device(drivers/core/uclass.c)
                                                    |--&gt;drv-&gt;probe(dev)
                                                        /*drivers/net/fec_mxc.c*/
                                                        U_BOOT_DRIVER(fecmxc_gem) = {
                                                            .name    = 'fecmxc',
                                                            .id    = UCLASS_ETH,
                                                            .of_match = fecmxc_ids,
                                                            .of_to_plat = fecmxc_of_to_plat,
                                                            .probe    = fecmxc_probe,
                                                            .remove    = fecmxc_remove,
                                                            .ops    = &amp;fecmxc_ops,
                                                            .priv_auto    = sizeof(struct fec_priv),
                                                            .plat_auto    = sizeof(struct eth_pdata),
                                                        };
                                                        |--&gt;fecmxc_probe(drivers/net/fec_mxc.c)/*探测和初始化*/
                                                            |--&gt;fec_get_miibus(drivers/net/fec_mxc.c)
                                                                |--&gt;mdio_alloc(drivers/net/fec_mxc.c)
                                                                |--&gt;bus-&gt;read = fec_phy_read;
                                                                |--&gt;bus-&gt;write = fec_phy_write;
                                                                |--&gt;mdio_register(common/miiphyutil.c)
                                                                |--&gt;fec_mii_setspeed(drivers/net/fec_mxc.c)
                                                            |--&gt;fec_phy_init(drivers/net/fec_mxc.c)
                                                                |--&gt;device_get_phy_addr(drivers/net/fec_mxc.c)
                                                                |--&gt;phy_connect(drivers/net/phy/phy.c)
                                                                    |--&gt;phy_find_by_mask(drivers/net/phy/phy.c)
                                                                        |--&gt;bus-&gt;reset(bus)
                                                                        |--&gt;get_phy_device_by_mask(drivers/net/phy/phy.c)
                                                                            |--&gt;create_phy_by_mask(drivers/net/phy/phy.c)
                                                                                |--&gt;phy_device_create(drivers/net/phy/phy.c)
                                                                                    |--&gt;phy_probe(drivers/net/phy/phy.c)
                                                                    |--&gt;phy_connect_dev(drivers/net/phy/phy.c)
                                                                        |--&gt;phy_reset(drivers/net/phy/phy.c)
                                                                |--&gt;phy_config(drivers/net/phy/phy.c)
                                                                    |--&gt;board_phy_config(drivers/net/phy/phy.c)
                                                                        |--&gt;phydev-&gt;drv-&gt;config(phydev)
                                                                            /*drivers/net/phy/smsc.c*/
                                                                            static struct phy_driver lan8710_driver = {
                                                                                .name = 'SMSC LAN8710/LAN8720',
                                                                                .uid = 0x0007c0f0,
                                                                                .mask = 0xffff0,
                                                                                .features = PHY_BASIC_FEATURES,
                                                                                .config = &amp;genphy_config_aneg,
                                                                                .startup = &amp;genphy_startup,
                                                                                .shutdown = &amp;genphy_shutdown,
                                                                            };
                                                                            |--&gt;genphy_config_aneg(drivers/net/phy/phy.c)
                                                                                |--&gt;phy_reset(需要手动调用)(drivers/net/phy/phy.c)
                                                                                |--&gt;genphy_setup_forced(drivers/net/phy/phy.c)
                                                                                |--&gt;genphy_config_advert(drivers/net/phy/phy.c)
                                                                                |--&gt;genphy_restart_aneg(drivers/net/phy/phy.c)
                                                    |--&gt;uclass_post_probe_device(drivers/core/uclass.c)
                                                        |--&gt;uc_drv-&gt;post_probe(drivers/core/uclass.c)
                                                            /*net/eth-uclass.c*/
                                                            UCLASS_DRIVER(ethernet) = {
                                                                .name        = 'ethernet',
                                                                .id        = UCLASS_ETH,
                                                                .post_bind    = eth_post_bind,
                                                                .pre_unbind    = eth_pre_unbind,
                                                                .post_probe    = eth_post_probe,
                                                                .pre_remove    = eth_pre_remove,
                                                                .priv_auto    = sizeof(struct eth_uclass_priv),
                                                                .per_device_auto    = sizeof(struct eth_device_priv),
                                                                .flags        = DM_UC_FLAG_SEQ_ALIAS,
                                                            };
                                                            |--&gt;eth_post_probe(net/eth-uclass.c)
                                                                |--&gt;eth_write_hwaddr(drivers/core/uclass.c)
                                    |--&gt;...
                                    |--&gt;run_main_loop(common/board_r.c)/*主循环，处理命令*/
                                        |--&gt;main_loop(common/main.c)
                                            |--&gt;bootdelay_process(common/autoboot.c)    /*读取环境变量bootdelay和bootcmd的内容*/
                                            |--&gt;autoboot_command(common/autoboot.c)        /*倒计时按下执行，没有操作执行bootcmd的参数*/
                                                |--&gt;abortboot(common/autoboot.c)
                                                    |--&gt;printf('Hit any key to stop autoboot: %2d ', bootdelay);
                                                    /*到这里就是我们看到uboot延时3s启动内核的地方*/
                                            |--&gt;cli_loop(common/cli.c)    /*倒计时按下space键,执行用户输入命令*/
```

### 编译跟踪：

./zoo 

./make_uboot_imgtr_bidir.sh

./config.mk：CPU := $(CONFIG_SYS_CPU:'%'=%)

.config：CONFIG_SYS_CPU='armv7'

关于在armv7的.S和.c文件中遇到的宏定义目前初步判断其定义位置在：

u-boot/configs/zynq-hkvs_imgtr_deconfig

zynq_hkvs_imgtr_defconfig

和.config中还有

（待定，待更新）

### 1、_start函数详解

网上查阅资料了解到u-boot.lds中的_start作为启动的第一语句，继续跟_start执行的语句，其定义在vectors.S

```
_start:
#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG
    .word   CONFIG_SYS_DV_NOR_BOOT_CFG
#endif
    b   reset
    ldr pc, _undefined_instruction
    ldr pc, _software_interrupt
    ldr pc, _prefetch_abort
    ldr pc, _data_abort
    ldr pc, _not_used
    ldr pc, _irq
    ldr pc, _fiq
/*
 *************************************************************************
 *
 * Indirect vectors table
 *
 * Symbols referenced here must be defined somewhere else
 *
 *************************************************************************
 */
    .globl  _undefined_instruction
    .globl  _software_interrupt
    .globl  _prefetch_abort
    .globl  _data_abort
    .globl  _not_used
    .globl  _irq
    .globl  _fiq
_undefined_instruction: .word undefined_instruction
_software_interrupt:    .word software_interrupt
_prefetch_abort:    .word prefetch_abort
_data_abort:        .word data_abort
_not_used:      .word not_used
_irq:           .word irq
_fiq:           .word fiq
    .balignl 16,0xdeadbeef
```

中断向量表中，先进行相对跳转到reset

而reset函数定义在arch/arm/cpu/armv7/start.S

### 2、reset函数详解

```
#include &lt;asm-offsets.h&gt;
#include &lt;config.h&gt;
#include &lt;asm/system.h&gt;
#include &lt;linux/linkage.h&gt;
/*************************************************************************
 *
 * Startup Code (reset vector)
 *
 * do important init only if we don't start from memory!
 * setup Memory and board specific bits prior to relocation.
 * relocate armboot to ram
 * setup stack
 *
 *************************************************************************/
    .globl  reset
    .globl  save_boot_params_ret
reset:
    /* Allow the board to save important registers */
    b   save_boot_params
```

在reset中执行跳转，跳转到save_boot_params

```
ENTRY(save_boot_params)
    b   save_boot_params_ret        @ back to my caller
ENDPROC(save_boot_params)
```

在save_boot_params中执行跳转，跳转到save_boot_params_ret

```
save_boot_params_ret:
    /*
     * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
     * except if in HYP mode already
     */
    mrs r0, cpsr
    and r1, r0, #0x1f       @ mask mode bits
    teq r1, #0x1a           @ test for HYP mode
    bicne r0, r0, #0x1f     @ clear all mode bits
    orrne r0, r0, #0x13     @ set SVC mode
    orr r0, r0, #0xc0       @ disable FIQ and IRQ
    msr cpsr,r0
/*
 * Setup vector:
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))
    /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
    mrc p15, 0, r0, c1, c0, 0   @ Read CP15 SCTLR Register
    bic r0, #CR_V               @ V = 0
    mcr p15, 0, r0, c1, c0, 0   @ Write CP15 SCTLR Register
    /* Set vector address in CP15 VBAR register */
    ldr r0, =_start
    mcr p15, 0, r0, c12, c0, 0  @Set VBAR
#endif
    /* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
    bl  cpu_init_cp15
    bl  cpu_init_crit
#endif
    bl  _main 
```

在save_boot_params_ret中执行指令：

指令分析：

![20190318104323545](../image/20190318104323545.png)

| 指令  | 使用方式                 | 作用                                                         |
| :---- | :----------------------- | :----------------------------------------------------------- |
| mrs   | `mrs r0, cpsr`           | 读取特殊寄存器cpsr的数据，并将数据写入到r0寄存器中           |
| and   | `and r1, r0, r2`         | 将r2和r0寄存器的数据相加并将和存到r1寄存器中                 |
| teq   | `teq r1, r2`             | 测试r1寄存器和r2寄存器的数据是否相等                         |
| bic   | bic r1, r1 , r2          | 根据r2中数据哪个位为1，清除r1对应的位，然后将结果存入r1。</description><guid isPermaLink="true">https://nobody-ZWQ.github.io/post/u-boot-qi-dong-liu-cheng-zhi-%20abortboot-an-xia-ctrl%2Bu.html</guid><pubDate>Thu, 18 Sep 2025 17:07:21 +0000</pubDate></item><item><title>display基础知识</title><link>https://nobody-ZWQ.github.io/post/display-ji-chu-zhi-shi.html</link><guid isPermaLink="true">https://nobody-ZWQ.github.io/post/display-ji-chu-zhi-shi.html</guid><pubDate>Thu, 18 Sep 2025 16:54:16 +0000</pubDate></item><item><title>USB枚举过程</title><link>https://nobody-ZWQ.github.io/post/USB-mei-ju-guo-cheng.html</link><description>## **USB 枚举的相对粗略的过程**

### 1. **物理连接**
- USB 设备插入主机（如 PC、嵌入式板卡）的 USB 端口。</description><guid isPermaLink="true">https://nobody-ZWQ.github.io/post/USB-mei-ju-guo-cheng.html</guid><pubDate>Thu, 18 Sep 2025 13:42:22 +0000</pubDate></item></channel></rss>