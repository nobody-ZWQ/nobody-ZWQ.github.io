{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "Blog Title", "subTitle": "Blog description", "avatarUrl": "https://github.githubassets.com/favicons/favicon.svg", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/USB-mei-ju-guo-cheng.html", "labels": ["documentation"], "postTitle": "USB\u679a\u4e3e\u8fc7\u7a0b", "postUrl": "post/USB-mei-ju-guo-cheng.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/1", "commentNum": 1, "description": "", "wordCount": 0, "top": 0, "createdAt": 1758202942, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-18", "dateLabelColor": "#0969da"}, "P2": {"htmlDir": "docs/post/display-ji-chu-zhi-shi.html", "labels": ["\u663e\u793a"], "postTitle": "display\u57fa\u7840\u77e5\u8bc6", "postUrl": "post/display-ji-chu-zhi-shi.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/2", "commentNum": 0, "description": "", "wordCount": 0, "top": 0, "createdAt": 1758214456, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-19", "dateLabelColor": "#0969da"}, "P3": {"htmlDir": "docs/post/u-boot-qi-dong-liu-cheng-zhi- abortboot-an-xia-ctrl+u.html", "labels": ["bootloader"], "postTitle": "u-boot\u542f\u52a8\u6d41\u7a0b\u4e4b abortboot\u6309\u4e0bctrl+u", "postUrl": "post/u-boot-qi-dong-liu-cheng-zhi-%20abortboot-an-xia-ctrl%2Bu.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/3", "commentNum": 0, "description": "", "wordCount": 0, "top": 0, "createdAt": 1758215241, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-19", "dateLabelColor": "#0969da"}, "P4": {"htmlDir": "docs/post/u-boot-qi-dong-liu-cheng-zhi- abortboot-wei-an-xia-ctrl+u.html", "labels": ["bootloader"], "postTitle": "u-boot\u542f\u52a8\u6d41\u7a0b\u4e4b abortboot\u672a\u6309\u4e0bctrl+u", "postUrl": "post/u-boot-qi-dong-liu-cheng-zhi-%20abortboot-wei-an-xia-ctrl%2Bu.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/4", "commentNum": 0, "wordCount": 36628, "description": "## 1\u3001\u8d77\u521d\u5728cli.c\u8c03\u7528\n\n```\n|-->auto_net_upgrade(u-boot/common/autoboot.c)\n|-->run_command_list(u-boot/common/cli.c)\n    |-->parse_string_outer(u-boot/common/cli_hush.c)\n        |-->setup_string_in_str(u-boot/common/cli_hush.c)\n        |-->parse_stream_outer(u-boot/common/cli_hush.c)\n            |-->initialize_context(u-boot/common/cli_hush.c)\n            |-->update_ifs_map(u-boot/common/cli_hush.c)\n            |-->parse_stream(u-boot/common/cli_hush.c)\n            |-->run_list(u-boot/common/cli_hush.c)\n                |-->run_list_real(u-boot/common/cli_hush.c)\n                    |-->make_list_in(u-boot/common/cli_hush.c)\n                    |-->run_pipe_real(u-boot/common/cli_hush.c)\n                        |-->cmd_process(u-boot/common/command.c)\n                            |-->find_cmd(u-boot/common/command.c)\n                            |-->cmd_call(u-boot/common/command.c)\n                                |-->do_bootz(u-boot/common/cmd_bootm.c)\n                                    |-->\n                |-->free_pipe_list(u-boot/common/cli_hush.c)\n```\n\n## 2\u3001\u8fdb\u5165cli_hush.c\u4e2d\u7684parse_string_outer\n\n### parse_string_outer\u51fd\u6570\u5b9a\u4e49\n\n```\nint parse_string_outer(const char *s, int flag)\n{\n    struct in_str input;\n    char *p = NULL;\n    int rcode;\n    if (!s)\n        return 1;\n    if (!*s)\n        return 0;\n    if (!(p = strchr(s, '\\n')) || *++p) {\n        p = xmalloc(strlen(s) + 2);\n        strcpy(p, s);\n        strcat(p, '\\n');\n        setup_string_in_str(&input, p);\n        rcode = parse_stream_outer(&input, flag);\n        free(p);\n        return rcode;\n    } else {\n    setup_string_in_str(&input, s);\n    return parse_stream_outer(&input, flag);\n    }\n}\n```\n\n### parse_stream_outer\u51fd\u6570\u5b9a\u4e49\n\n```\nstatic int parse_stream_outer(struct in_str *inp, int flag)\n{\n    struct p_context ctx;\n    o_string temp=NULL_O_STRING;\n    int rcode;\n    int code = 1;\n    do {\n        ctx.type = flag;\n        initialize_context(&ctx);\n        update_ifs_map();\n        if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)';$&|', 0);\n        inp->promptmode=1;\n        rcode = parse_stream(&temp, &ctx, inp,\n                     flag & FLAG_CONT_ON_NEWLINE ? -1 : '\\n');\n        if (rcode == 1) flag_repeat = 0;\n        if (rcode != 1 && ctx.old_flag != 0) {\n            syntax();\n            flag_repeat = 0;\n        }\n        if (rcode != 1 && ctx.old_flag == 0) {\n            done_word(&temp, &ctx);\n            done_pipe(&ctx,PIPE_SEQ);\n            code = run_list(ctx.list_head);\n            if (code == -2) {   /* exit */\n                b_free(&temp);\n                code = 0;\n                /* XXX hackish way to not allow exit from main loop */\n                if (inp->peek == file_peek) {\n                    printf('exit not allowed from main input shell.\\n');\n                    continue;\n                }\n                break;\n            }\n            if (code == -1)\n                flag_repeat = 0;\n        } else {\n            if (ctx.old_flag != 0) {\n                free(ctx.stack);\n                b_reset(&temp);\n            }\n            if (inp->__promptme == 0) printf('<INTERRUPT>\\n');\n            inp->__promptme = 1;\n            temp.nonnull = 0;\n            temp.quote = 0;\n            inp->p = NULL;\n            free_pipe_list(ctx.list_head,0);\n        }\n        b_free(&temp);\n    /* loop on syntax errors, return on EOF */\n    } while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP) &&\n        (inp->peek != static_peek || b_peek(inp)));\n    return (code != 0) ? 1 : 0;\n}\n```\n\n\n\n### run_list_real\u51fd\u6570\u5b9a\u4e49\n\n```\nstatic int run_list_real(struct pipe *pi)\n{\n    char *save_name = NULL;\n    char **list = NULL;\n    char **save_list = NULL;\n    struct pipe *rpipe;\n    int flag_rep = 0;\n    int rcode=0, flag_skip=1;\n    int flag_restore = 0;\n    int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */\n    reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;\n    /* check syntax for 'for' */\n    for (rpipe = pi; rpipe; rpipe = rpipe->next) {\n        if ((rpipe->r_mode == RES_IN ||\n            rpipe->r_mode == RES_FOR) &&\n            (rpipe->next == NULL)) {\n                syntax();\n#ifdef __U_BOOT__\n                flag_repeat = 0;\n#endif\n                return 1;\n        }\n        if ((rpipe->r_mode == RES_IN &&\n            (rpipe->next->r_mode == RES_IN &&\n            rpipe->next->progs->argv != NULL))||\n            (rpipe->r_mode == RES_FOR &&\n            rpipe->next->r_mode != RES_IN)) {\n                syntax();\n#ifdef __U_BOOT__\n                flag_repeat = 0;\n#endif\n                return 1;\n        }\n    }\n    for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {\n        if (pi->r_mode == RES_WHILE || pi->r_mode == RES_UNTIL ||\n            pi->r_mode == RES_FOR) {\n#ifdef __U_BOOT__\n                /* check Ctrl-C */\n                ctrlc();\n                if ((had_ctrlc())) {\n                    return 1;\n                }\n#endif\n                flag_restore = 0;\n                if (!rpipe) {\n                    flag_rep = 0;\n                    rpipe = pi;\n                }\n        }\n        rmode = pi->r_mode;\n        debug_printf('rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\\n', rmode, if_code, next_if_code, skip_more_in_this_rmode);\n        if (rmode == skip_more_in_this_rmode && flag_skip) {\n            if (pi->followup == PIPE_SEQ) flag_skip=0;\n            continue;\n        }\n        flag_skip = 1;\n        skip_more_in_this_rmode = RES_XXXX;\n        if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;\n        if (rmode == RES_THEN &&  if_code) continue;\n        if (rmode == RES_ELSE && !if_code) continue;\n        if (rmode == RES_ELIF && !if_code) break;\n        if (rmode == RES_FOR && pi->num_progs) {\n            if (!list) {\n                /* if no variable values after 'in' we skip 'for' */\n                if (!pi->next->progs->argv) continue;\n                /* create list of variable values */\n                list = make_list_in(pi->next->progs->argv,\n                    pi->progs->argv[0]);\n                save_list = list;\n                save_name = pi->progs->argv[0];\n                pi->progs->argv[0] = NULL;\n                flag_rep = 1;\n            }\n            if (!(*list)) {\n                free(pi->progs->argv[0]);\n                free(save_list);\n                list = NULL;\n                flag_rep = 0;\n                pi->progs->argv[0] = save_name;\n                continue;\n            } else {\n                /* insert new value from list for variable */\n                if (pi->progs->argv[0])\n                    free(pi->progs->argv[0]);\n                pi->progs->argv[0] = *list++;\n            }\n        }\n        if (rmode == RES_IN) continue;\n        if (rmode == RES_DO) {\n            if (!flag_rep) continue;\n        }\n        if (rmode == RES_DONE) {\n            if (flag_rep) {\n                flag_restore = 1;\n            } else {\n                rpipe = NULL;\n            }\n        }\n        if (pi->num_progs == 0) continue;\n        rcode = run_pipe_real(pi);\n        debug_printf('run_pipe_real returned %d\\n',rcode);\n        if (rcode < -1) {\n            last_return_code = -rcode - 2;\n            return -2;  /* exit */\n        }\n        last_return_code=(rcode == 0) ? 0 : 1;\n        if ( rmode == RES_IF || rmode == RES_ELIF )\n            next_if_code=rcode;  /* can be overwritten a number of times */\n        if (rmode == RES_WHILE)\n            flag_rep = !last_return_code;\n        if (rmode == RES_UNTIL)\n            flag_rep = last_return_code;\n        if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||\n             (rcode!=EXIT_SUCCESS && pi->followup==PIPE_AND) )\n            skip_more_in_this_rmode=rmode;\n    }\n    return rcode;\n}\n```\n\n\n\n### run_pipe_real\u51fd\u6570\u5b9e\u9645\u8fd0\u884c\u90e8\u5206\uff1a\n\n```\nstatic int run_pipe_real(struct pipe *pi)\n{\n    int i;\n    int nextin;\n    int flag = do_repeat ? CMD_FLAG_REPEAT : 0;\n    struct child_prog *child;\n    char *p;\n    nextin = 0;\n    if (pi->num_progs == 1) child = & (pi->progs[0]);\n     \n    if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {\n        for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }\n        for (i = 0; is_assignment(child->argv[i]); i++) {\n            p = insert_var_value(child->argv[i]);\n            set_local_var(p, 0);\n            if (p != child->argv[i]) {\n                child->sp--;\n                free(p);\n            }\n        }\n        /* Process the command */\n        return cmd_process(flag, child->argc, child->argv,\n                   &flag_repeat, NULL);\n    }\n}\n```\n\n## 3\u3001\u8fdb\u5165\u5230command.c\u4e2d\u7684cmd_process\n\n### cmd_process \u51fd\u6570\u5b9e\u9645\u8fd0\u884c\u90e8\u5206\n\n```\nenum command_ret_t cmd_process(int flag, int argc, char * const argv[],\n                   int *repeatable, ulong *ticks)\n{\n    enum command_ret_t rc = CMD_RET_SUCCESS;\n    cmd_tbl_t *cmdtp;\n    /* Look up command in command table */\n    cmdtp = find_cmd(argv[0]);                  //\u521d\u59cb\u7684cmd\u4e5f\u5c31\u662fargv[0]\u5728\u7ecf\u8fc7find_cmd\u51fd\u6570\u540e\u5c06\u5f97\u5230cmd\u76f8\u5173\u7684\u51fd\u6570\uff1b\u5176\u8fc7\u7a0b\u6682\u4e0d\u6e05\u695a\n                                                //\u4f8b\uff1a\u6b64\u5904\u7684argv[0]\u662fbooz\uff0c\u7ecf\u8fc7find_cmd\u540e\u5f97\u5230cmdtp->cmd\u4e3ado_bootz\n    /* found - check max args */\n    if (argc > cmdtp->maxargs)\n        rc = CMD_RET_USAGE;\n    /* avoid 'bootd' recursion */\n    if (cmdtp->cmd == do_bootd) {\n        if (flag & CMD_FLAG_BOOTD) {\n            puts(''bootd' recursion detected\\n');\n            rc = CMD_RET_FAILURE;\n        } else {\n            flag |= CMD_FLAG_BOOTD;\n        }\n    }\n    /* If OK so far, then do the command */\n    if (!rc) {\n        if (ticks)\n            *ticks = get_timer(0);\n        rc = cmd_call(cmdtp, flag, argc, argv); //cmd\u76f8\u5173\u7684\u51fd\u6570do_bootz\u662f\u5728\u6b64\u51fd\u6570\u4e2d\u6267\u884c\u7684\n        if (ticks)\n            *ticks = get_timer(*ticks);\n        *repeatable &= cmdtp->repeatable;\n    }\n    if (rc == CMD_RET_USAGE)\n        rc = cmd_usage(cmdtp);\n    return rc;\n}\n```\n\n### find_cmd\u51fd\u6570\u5b9e\u9645\u6267\u884c\uff1a\n\n```\n#define ll_entry_start(_type, _list)                    \\\n({                                  \\\n    static char start[0] __aligned(4) __attribute__((unused,    \\\n        section('.u_boot_list_2_'#_list'_1')));         \\\n    (_type *)&start;                        \\\n})\n \n#define ll_entry_end(_type, _list)                  \\\n({                                  \\\n    static char end[0] __aligned(4) __attribute__((unused,  \\\n        section('.u_boot_list_2_'#_list'_3')));         \\\n    (_type *)&end;                          \\\n})\n \n#define ll_entry_count(_type, _list)                    \\\n    ({                              \\\n        _type *start = ll_entry_start(_type, _list);        \\\n        _type *end = ll_entry_end(_type, _list);        \\\n        unsigned int _ll_result = end - start;          \\\n        _ll_result;                     \\\n    })\n \ncmd_tbl_t *find_cmd_tbl(const char *cmd, cmd_tbl_t *table, int table_len)\n{\n    cmd_tbl_t *cmdtp;\n    cmd_tbl_t *cmdtp_temp = table;  /* Init value */\n    const char *p;\n    int len;\n    int n_found = 0;\n    if (!cmd)\n        return NULL;\n    /*\n     * Some commands allow length modifiers (like 'cp.b');\n     * compare command name only until first dot.\n     */\n    len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);\n    for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {\n        if (strncmp(cmd, cmdtp->name, len) == 0) {\n            if (len == strlen(cmdtp->name))\n                return cmdtp;   /* full match */\n            cmdtp_temp = cmdtp; /* abbreviated command ? */\n            n_found++;\n        }\n    }\n    if (n_found == 1) {         /* exactly one match */\n        return cmdtp_temp;\n    }\n    return NULL;    /* not found or ambiguous command */\n}\n \ncmd_tbl_t *find_cmd(const char *cmd)\n{\n    cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);\n    const int len = ll_entry_count(cmd_tbl_t, cmd);\n    return find_cmd_tbl(cmd, start, len);\n}\n```\n\n### cmd_call\u51fd\u6570\u5b9e\u9645\u6267\u884c\uff1a\n\n```\nstatic int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])\n{\n    int result;\n    result = (cmdtp->cmd)(cmdtp, flag, argc, argv);      //do_bootz\u51fd\u6570\u5728\u6b64\u8c03\u7528\u6267\u884c\n    if (result)\n        debug('Command failed, result=%d', result);\n    return result;\n}\n```\n\n## 4\u3001\u8fdb\u5165\u5230cmd_bootm\u51fd\u6570\u4e2d\u7684do_bootz\n\n### do_bootz\u51fd\u6570\u5b9e\u9645\u6267\u884c\uff1a\n\n```\nint do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])\n{\n    int ret;\n    /* Consume 'bootz' \u6b64\u65f6\u7684argc\u662f4\uff0c\u8868\u793a4\u4e2a\u53c2\u6570\uff0c\u540c\u65f6argv[0]\u662fbootz*/  \n    argc--; argv++;     //\u6b64\u65f6argc\u662f3\uff0c\u8fd8\u67093\u4e2a\u53c2\u6570\uff0c\u540c\u65f6argv[0]\u662fbootz\u5f15\u5bfc\u5185\u6838\u7684\u5730\u57400x2080000\n    if (bootz_start(cmdtp, flag, argc, argv, &images))          //images\u5f53\u524d\u8fd8\u53ea\u662f\u4e2a\u7a7a\u7684\u7ed3\u6784\u4f53\u5b9e\u4f8b\n        return 1;\n    /*\n     * We are doing the BOOTM_STATE_LOADOS state ourselves, so must\n     * disable interrupts ourselves\n     */\n    bootm_disable_interrupts();\n    images.os.os = IH_OS_LINUX;\n    ret = do_bootm_states(cmdtp, flag, argc, argv,\n                  BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |\n                  BOOTM_STATE_OS_GO,\n                  &images, 1);\n    return ret;\n}\n```\n\n### 1\u3001bootz_start\u51fd\u6570\u5b9e\u9645\u6267\u884c\uff1a\n\n```\nstatic int bootz_start(cmd_tbl_t *cmdtp, int flag, int argc,\n            char * const argv[], bootm_headers_t *images)\n{\n    int ret;\n    ulong zi_start, zi_end;\n    ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START,\n                  images, 1);\n    /* Setup Linux kernel zImage entry point */\n    if (!argc) {\n        images->ep = load_addr;\n        debug('*  kernel: default image load address = 0x%08lx\\n',\n                load_addr);\n    } else {\n        images->ep = simple_strtoul(argv[0], NULL, 16);\n        debug('*  kernel: cmdline image address = 0x%08lx\\n',\n            images->ep);\n    }\n    printf('images-ep %x\\n', images->ep);\n    ret = bootz_setup(images->ep, &zi_start, &zi_end);\n    if (ret != 0)\n        return 1;\n    lmb_reserve(&images->lmb, images->ep, zi_end - zi_start);\n    /*\n     * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not\n     * have a header that provide this informaiton.\n     */\n    if (bootm_find_ramdisk_fdt(flag, argc, argv))\n        return 1;\n    return 0;\n}\n```\n\n### do_bootm_states\u51fd\u6570\u5b9a\u4e49\n\n```\n int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],\n            int states, bootm_headers_t *images, int boot_progress)\n{\n    boot_os_fn *boot_fn;\n    ulong iflag = 0;\n    int ret = 0, need_boot_fn;\n    images->state |= states;\n    /*\n     * Work through the states and see how far we get. We stop on\n     * any error.\n     */\n    if (states & BOOTM_STATE_START)                     //states=1,ret=0;BOOTM_STATE_START=(0x00000001);\n        ret = bootm_start(cmdtp, flag, argc, argv);     //\u5728\u672c\u51fd\u6570\u4e2d\u552f\u4e8c\u9700\u8981\u6b63\u5e38\u6267\u884c\u7684\u51fd\u6570\u4e4b\u4e00\n    if (!ret && (states & BOOTM_STATE_FINDOS))          //states=1,ret=0;BOOTM_STATE_FINDOS=(0x00000002);\n        ret = bootm_find_os(cmdtp, flag, argc, argv);  \n    if (!ret && (states & BOOTM_STATE_FINDOTHER)) {     //states=1,ret=0;BOOTM_STATE_FINDOTHER=(0x00000004);\n        ret = bootm_find_other(cmdtp, flag, argc, argv);\n        argc = 0;   /* consume the args */\n    }\n    /* From now on, we need the OS boot function */     //\u6b64\u65f6states=1,ret=0;\n    if (ret)\n        return ret;\n    boot_fn = bootm_os_get_boot_func(images->os.os); //\u5728\u672c\u51fd\u6570\u4e2d\u552f\u4e8c\u9700\u8981\u6b63\u5e38\u6267\u884c\u7684\u51fd\u6570\u4e4b\u4e00\n    need_boot_fn = states & (BOOTM_STATE_OS_CMDLINE |\n            BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |\n            BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);        //\u8fd9\u90e8\u5206\u7684\u5b8f0x00000 7E 0\n    /* Call various other states that are not generally used */ //\u6b64\u65f6boot_fn = NULL,need_boot_fn = 0x700\n    if (!ret && (states & BOOTM_STATE_OS_CMDLINE))              //states=1,ret=0;BOOTM_STATE_OS_CMDLINE=(0x00000040);\n        ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);\n    if (!ret && (states & BOOTM_STATE_OS_BD_T))                 //states=1,ret=0;BOOTM_STATE_OS_BD_T=(0x00000080);\n        ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images);\n    if (!ret && (states & BOOTM_STATE_OS_PREP))                 //states=1,ret=0;BOOTM_STATE_OS_PREP=(0x00000100);\n        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);\n    /* Check for unsupported subcommand. */\n    if (ret) {\n        puts('subcommand not supported\\n');\n        return ret;\n    }\n    /* Now run the OS! We hope this doesn't return */\n    if (!ret && (states & BOOTM_STATE_OS_GO))                   //ret =0;states =1;BOOTM_STATE_OS_GO=0x00000400;\n        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,\n                images, boot_fn);\n    /* Deal with any fallout */\nerr:\n    if (iflag)                                          //iflag= 0;ret =0;\n        enable_interrupts();\n    if (ret == BOOTM_ERR_UNIMPLEMENTED)\n        bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);\n    else if (ret == BOOTM_ERR_RESET)\n        do_reset(cmdtp, flag, argc, argv);\n    return ret;\n}\n```\n\n#### bootm_start\u51fd\u6570\u5b9a\u4e49\u5b9e\u9645\u6267\u884c\uff1a\n\n```\nstatic int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc,\n               char * const argv[])\n{\n    memset((void *)&images, 0, sizeof(images));\n    images.verify = getenv_yesno('verify');       //\u4ece\u73af\u5883\u53d8\u91cf\u4e2d\u83b7\u53d6verify\u7684\u503c\n    boot_start_lmb(&images);\n    bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, 'bootm_start');\n    images.state = BOOTM_STATE_START;\n    return 0;\n}\n```\n\n#### 1\u3001getenv_yesno\u51fd\u6570\u5b9a\u4e49 \u5b9e\u9645\u6267\u884c\uff1a\n\n```\nchar *getenv(const char *name)\n{\n    if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */\n        ENTRY e, *ep;\n        WATCHDOG_RESET();\n        e.key   = name;                         //\u5c06\u9700\u8981\u67e5\u627e\u7684\u53d8\u91cf\u8f6c\u4e3aENTRY\u7ed3\u6784\u4f53\u53d8\u91cf\u7684\u952e\u503c\n        e.data  = NULL;\n        hsearch_r(e, FIND, &ep, &env_htab, 0);\n        return ep ? ep->data : NULL;\n    }\n    /* restricted capabilities before import */\n    if (getenv_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)\n        return (char *)(gd->env_buf);\n    return NULL;\n}\nint getenv_yesno(const char *var)\n{\n    char *s = getenv(var);\n    if (s == NULL)\n        return -1;\n    return (*s == '1' || *s == 'y' || *s == 'Y' || *s == 't' || *s == 'T') ?\n        1 : 0;\n}\n```\n\ngetenv\u51fd\u6570\u5b9a\u4e49\uff1a\n\n\u672c\u51fd\u6570\u6d89\u53ca\u5230env\u53d8\u91cf\u7684\u76f8\u5173\u4fee\u6539\uff0c\u5b9e\u9645\u89e3\u6790\u6682\u672a\u5b8c\u6210\uff0c\u4ec5\u4ec5\u521d\u6b65\u5b8c\u6210hsearch_r\u51fd\u6570\u7684\u7406\u89e3\uff08\uff09\uff0cgetenc_f\u51fd\u6570\u7684\u7406\u89e3\u5206\u6790\u6682\u672a\u5b8c\u6210\u56e0\u4e3a\u597d\u50cf\u5f88\u591a\u5730\u65b9\u5747\u6709\u76f8\u5173\u7684\u8c03\u7528\u5bfc\u81f4\u6253\u5370\u4fe1\u606f\u6bd4\u8f83\u6742\u4e0d\u597d\u786e\u5b9a\n\nhsearch_r\u51fd\u6570\u5b9a\u4e49\n\n```\nint hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,\n          struct hsearch_data *htab, int flag)\n{\n    unsigned int hval;\n    unsigned int count;\n    unsigned int len = strlen(item.key);\n    unsigned int idx;\n    unsigned int first_deleted = 0;\n    int ret;\n    /* Compute an value for the given string. Perhaps use a better method. */\n    hval = len;\n    count = len;\n    //hash\u8868\u952e\u503c\u751f\u6210\u7b97\u6cd5:\n    //\u5c06item.key---\u73af\u5883\u53d8\u91cfname\u4e2d\u7684\u5b57\u7b26\u79fb\u4f4d\u5e76\u7d2f\u52a0\uff0c\u7136\u540e\u6a21hash\u8868\u9879\u6570\uff0c\u5373\u4e3a\u8be5\u73af\u5883\u53d8\u91cf\u5728hash\u8868\u9879\u4e2d\u7684\u6570\u7ec4\u7d22\u5f15---hash\u8868\u952e\u503c\u3002", "top": 0, "createdAt": 1758216055, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-19", "dateLabelColor": "#0969da"}}, "singeListJson": {}, "labelColorDict": {"bootloader": "#8b731a", "bug": "#d73a4a", "camera": "#f9e403", "documentation": "#0075ca", "duplicate": "#cfd3d7", "enhancement": "#a2eeef", "good first issue": "#7057ff", "help wanted": "#008672", "invalid": "#e4e669", "question": "#d876e3", "RISC-V\u5b66\u4e60": "#9fcee7", "USB": "#18f954", "wontfix": "#ffffff", "\u4e2d\u65ad": "#f67da5", "\u5b58\u50a8": "#8022d9", "\u663e\u793a": "#2197bb"}, "displayTitle": "Blog Title", "faviconUrl": "https://github.githubassets.com/favicons/favicon.svg", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://nobody-ZWQ.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}