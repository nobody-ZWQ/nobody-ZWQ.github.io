{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "Blog Title", "subTitle": "Blog description", "avatarUrl": "https://github.githubassets.com/favicons/favicon.svg", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/USB-mei-ju-guo-cheng.html", "labels": ["USB"], "postTitle": "USB\u679a\u4e3e\u8fc7\u7a0b", "postUrl": "post/USB-mei-ju-guo-cheng.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/1", "commentNum": 0, "wordCount": 2979, "description": "## **USB \u679a\u4e3e\u7684\u76f8\u5bf9\u7c97\u7565\u7684\u8fc7\u7a0b**\n\n### 1. **\u7269\u7406\u8fde\u63a5**\n- USB \u8bbe\u5907\u63d2\u5165\u4e3b\u673a\uff08\u5982 PC\u3001\u5d4c\u5165\u5f0f\u677f\u5361\uff09\u7684 USB \u7aef\u53e3\u3002", "top": 0, "createdAt": 1758202942, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-18", "dateLabelColor": "#0969da"}, "P2": {"htmlDir": "docs/post/display-ji-chu-zhi-shi.html", "labels": ["\u663e\u793a"], "postTitle": "display\u57fa\u7840\u77e5\u8bc6", "postUrl": "post/display-ji-chu-zhi-shi.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/2", "commentNum": 0, "description": "", "wordCount": 0, "top": 0, "createdAt": 1758214456, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-19", "dateLabelColor": "#0969da"}, "P3": {"htmlDir": "docs/post/u-boot-qi-dong-liu-cheng-zhi- abortboot-an-xia-ctrl+u.html", "labels": ["u-boot\u542f\u52a8linux"], "postTitle": "u-boot\u542f\u52a8\u6d41\u7a0b\u4e4b abortboot\u6309\u4e0bctrl+u", "postUrl": "post/u-boot-qi-dong-liu-cheng-zhi-%20abortboot-an-xia-ctrl%2Bu.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/3", "commentNum": 0, "wordCount": 47522, "description": "### **\u4ee3\u7801\u8c03\u7528\u8ddf\u8e2a**\n```\nu-boot.lds:(arch/arm/cpu/u-boot.lds)\n    |-->_start:(arch/arm/lib/vectors.S)\n        |-->reset(arch/arm/cpu/armv7/start.S)   \n            |-->save_boot_params(arch/arm/cpu/armv7/start.S)/*\u5c06\u5f15\u5bfc\u53c2\u6570\u4fdd\u5b58\u5230\u5185\u5b58\u4e2d*/\n                |-->save_boot_params_ret(arch/arm/cpu/armv7/start.S)\n                    |-->cpu_init_cp15(arch/arm/cpu/armv7/start.S)/*\u521d\u59cb\u5316*/\n                    |-->cpu_init_crit(arch/arm/cpu/armv7/start.S)\n                        |-->lowlevel_init(arch/arm/cpu/armv7/lowlevel_init.S)\n                    |-->_main(arch/arm/lib/crt0.S)\n                        |-->board_init_f_alloc_reserve(common/init/board_init.c)/*\u4e3au-boot\u7684gd\u7ed3\u6784\u4f53\u5206\u914d\u7a7a\u95f4*/\n                        |-->board_init_f_init_reserve(common/init/board_init.c)    /*\u5c06gd\u7ed3\u6784\u4f53\u6e05\u96f6*/\n                        |-->board_init_f(common/board_f.c)\n                            |-->initcall_run_list(include/initcall.h)    /*\u521d\u59cb\u5316\u5e8f\u5217\u51fd\u6570*/\n                                |-->init_sequence_f[](common/board_f.c)    /* \u521d\u59cb\u5316\u5e8f\u5217\u51fd\u6570\u6570\u7ec4 */\n                                    |-->board_early_init_f(board/freescale/mx6ull_toto/mx6ull_toto.c)/*\u521d\u59cb\u5316\u4e32\u53e3\u7684IO\u914d\u7f6e*/\n                                    |-->timer_init(arch/arm/imx-common/timer.c)    /*\u521d\u59cb\u5316\u5185\u6838\u5b9a\u65f6\u5668\uff0c\u4e3auboot\u63d0\u4f9b\u65f6\u949f\u8282\u62cd*/\n                                    |-->init_baud_rate(common/board_f.c)        /*\u521d\u59cb\u5316\u6ce2\u7279\u7387*/\n                                    |-->serial_init(drivers/serial/serial.c)    /*\u521d\u59cb\u5316\u4e32\u53e3\u901a\u4fe1\u8bbe\u7f6e*/\n                                    |-->console_init_f(common/console.c)        /*\u521d\u59cb\u5316\u63a7\u5236\u53f0*/\n                                    |-->...\n                        |-->relocate_code(arch/arm/lib/relocate.S)    /*\u4e3b\u8981\u5b8c\u6210\u955c\u50cf\u62f7\u8d1d\u548c\u91cd\u5b9a\u4f4d*/\n                        |-->relocate_vectors(arch/arm/lib/relocate.S)/*\u91cd\u5b9a\u4f4d\u5411\u91cf\u8868*/\n                        |-->board_init_r(common/board_r.c)/*\u677f\u7ea7\u521d\u59cb\u5316*/\n                            |-->initcall_run_list(include/initcall.h)/*\u521d\u59cb\u5316\u5e8f\u5217\u51fd\u6570*/\n                                |-->init_sequence_r[](common/board_f.c)/*\u5e8f\u5217\u51fd\u6570*/\n                                    |-->initr_reloc(common/board_r.c)    /*\u8bbe\u7f6e gd->flags,\u6807\u8bb0\u91cd\u5b9a\u4f4d\u5b8c\u6210*/\n                                    |-->serial_initialize(drivers/serial/serial-uclass.c)/*\u521d\u59cb\u5316\u4e32\u53e3*/\n                                        |-->serial_init(drivers/serial/serial-uclass.c)     /*\u521d\u59cb\u5316\u4e32\u53e3*/\n                                    |-->initr_mmc(common/board_r.c)                         /*\u521d\u59cb\u5316emmc*/\n                                        |-->mmc_initialize(drivers/mmc/mmc.c)\n                                            |-->mmc_do_preinit(drivers/mmc/mmc.c)\n                                                |-->mmc_start_init(drivers/mmc/mmc.c)\n                                    |-->console_init_r(common/console.c)                /*\u521d\u59cb\u5316\u63a7\u5236\u53f0*/\n                                    |-->interrupt_init(arch/arm/lib/interrupts.c)        /*\u521d\u59cb\u5316\u4e2d\u65ad*/\n                                    |-->initr_net(common/board_r.c)                        /*\u521d\u59cb\u5316\u7f51\u7edc\u8bbe\u5907*/\n                                        |-->eth_initialize(net/eth-uclass.c)\n                                            |-->eth_common_init(net/eth_common.c)\n                                                |-->phy_init(drivers/net/phy/phy.c)\n                                            |-->uclass_first_device_check(drivers/core/uclass.c)\n                                                |-->uclass_find_first_device(drivers/core/uclass.c)\n                                                |-->device_probe(drivers/core/device.c)\n                                                    |-->device_of_to_plat(drivers/core/device.c)\n                                                        |-->drv->of_to_plat\n                                                            |-->fecmxc_of_to_plat(drivers/net/fec_mxc.c)/*\u89e3\u6790\u8bbe\u5907\u6811\u4fe1\u606f*/\n                                                    |-->device_get_uclass_id(drivers/core/device.c)\n                                                    |-->uclass_pre_probe_device(drivers/core/uclass.c)\n                                                    |-->drv->probe(dev)\n                                                        /*drivers/net/fec_mxc.c*/\n                                                        U_BOOT_DRIVER(fecmxc_gem) = {\n                                                            .name    = 'fecmxc',\n                                                            .id    = UCLASS_ETH,\n                                                            .of_match = fecmxc_ids,\n                                                            .of_to_plat = fecmxc_of_to_plat,\n                                                            .probe    = fecmxc_probe,\n                                                            .remove    = fecmxc_remove,\n                                                            .ops    = &fecmxc_ops,\n                                                            .priv_auto    = sizeof(struct fec_priv),\n                                                            .plat_auto    = sizeof(struct eth_pdata),\n                                                        };\n                                                        |-->fecmxc_probe(drivers/net/fec_mxc.c)/*\u63a2\u6d4b\u548c\u521d\u59cb\u5316*/\n                                                            |-->fec_get_miibus(drivers/net/fec_mxc.c)\n                                                                |-->mdio_alloc(drivers/net/fec_mxc.c)\n                                                                |-->bus->read = fec_phy_read;\n                                                                |-->bus->write = fec_phy_write;\n                                                                |-->mdio_register(common/miiphyutil.c)\n                                                                |-->fec_mii_setspeed(drivers/net/fec_mxc.c)\n                                                            |-->fec_phy_init(drivers/net/fec_mxc.c)\n                                                                |-->device_get_phy_addr(drivers/net/fec_mxc.c)\n                                                                |-->phy_connect(drivers/net/phy/phy.c)\n                                                                    |-->phy_find_by_mask(drivers/net/phy/phy.c)\n                                                                        |-->bus->reset(bus)\n                                                                        |-->get_phy_device_by_mask(drivers/net/phy/phy.c)\n                                                                            |-->create_phy_by_mask(drivers/net/phy/phy.c)\n                                                                                |-->phy_device_create(drivers/net/phy/phy.c)\n                                                                                    |-->phy_probe(drivers/net/phy/phy.c)\n                                                                    |-->phy_connect_dev(drivers/net/phy/phy.c)\n                                                                        |-->phy_reset(drivers/net/phy/phy.c)\n                                                                |-->phy_config(drivers/net/phy/phy.c)\n                                                                    |-->board_phy_config(drivers/net/phy/phy.c)\n                                                                        |-->phydev->drv->config(phydev)\n                                                                            /*drivers/net/phy/smsc.c*/\n                                                                            static struct phy_driver lan8710_driver = {\n                                                                                .name = 'SMSC LAN8710/LAN8720',\n                                                                                .uid = 0x0007c0f0,\n                                                                                .mask = 0xffff0,\n                                                                                .features = PHY_BASIC_FEATURES,\n                                                                                .config = &genphy_config_aneg,\n                                                                                .startup = &genphy_startup,\n                                                                                .shutdown = &genphy_shutdown,\n                                                                            };\n                                                                            |-->genphy_config_aneg(drivers/net/phy/phy.c)\n                                                                                |-->phy_reset(\u9700\u8981\u624b\u52a8\u8c03\u7528)(drivers/net/phy/phy.c)\n                                                                                |-->genphy_setup_forced(drivers/net/phy/phy.c)\n                                                                                |-->genphy_config_advert(drivers/net/phy/phy.c)\n                                                                                |-->genphy_restart_aneg(drivers/net/phy/phy.c)\n                                                    |-->uclass_post_probe_device(drivers/core/uclass.c)\n                                                        |-->uc_drv->post_probe(drivers/core/uclass.c)\n                                                            /*net/eth-uclass.c*/\n                                                            UCLASS_DRIVER(ethernet) = {\n                                                                .name        = 'ethernet',\n                                                                .id        = UCLASS_ETH,\n                                                                .post_bind    = eth_post_bind,\n                                                                .pre_unbind    = eth_pre_unbind,\n                                                                .post_probe    = eth_post_probe,\n                                                                .pre_remove    = eth_pre_remove,\n                                                                .priv_auto    = sizeof(struct eth_uclass_priv),\n                                                                .per_device_auto    = sizeof(struct eth_device_priv),\n                                                                .flags        = DM_UC_FLAG_SEQ_ALIAS,\n                                                            };\n                                                            |-->eth_post_probe(net/eth-uclass.c)\n                                                                |-->eth_write_hwaddr(drivers/core/uclass.c)\n                                    |-->...\n                                    |-->run_main_loop(common/board_r.c)/*\u4e3b\u5faa\u73af\uff0c\u5904\u7406\u547d\u4ee4*/\n                                        |-->main_loop(common/main.c)\n                                            |-->bootdelay_process(common/autoboot.c)    /*\u8bfb\u53d6\u73af\u5883\u53d8\u91cfbootdelay\u548cbootcmd\u7684\u5185\u5bb9*/\n                                            |-->autoboot_command(common/autoboot.c)        /*\u5012\u8ba1\u65f6\u6309\u4e0b\u6267\u884c\uff0c\u6ca1\u6709\u64cd\u4f5c\u6267\u884cbootcmd\u7684\u53c2\u6570*/\n                                                |-->abortboot(common/autoboot.c)\n                                                    |-->printf('Hit any key to stop autoboot: %2d ', bootdelay);\n                                                    /*\u5230\u8fd9\u91cc\u5c31\u662f\u6211\u4eec\u770b\u5230uboot\u5ef6\u65f63s\u542f\u52a8\u5185\u6838\u7684\u5730\u65b9*/\n                                            |-->cli_loop(common/cli.c)    /*\u5012\u8ba1\u65f6\u6309\u4e0bspace\u952e,\u6267\u884c\u7528\u6237\u8f93\u5165\u547d\u4ee4*/\n```\n\n### \u7f16\u8bd1\u8ddf\u8e2a\uff1a\n\n./zoo \n\n./make_uboot_imgtr_bidir.sh\n\n./config.mk\uff1aCPU := $(CONFIG_SYS_CPU:'%'=%)\n\n.config\uff1aCONFIG_SYS_CPU='armv7'\n\n\u5173\u4e8e\u5728armv7\u7684.S\u548c.c\u6587\u4ef6\u4e2d\u9047\u5230\u7684\u5b8f\u5b9a\u4e49\u76ee\u524d\u521d\u6b65\u5224\u65ad\u5176\u5b9a\u4e49\u4f4d\u7f6e\u5728\uff1a\n\nu-boot/configs/zynq-hkvs_imgtr_deconfig\n\nzynq_hkvs_imgtr_defconfig\n\n\u548c.config\u4e2d\u8fd8\u6709\n\n\uff08\u5f85\u5b9a\uff0c\u5f85\u66f4\u65b0\uff09\n\n### 1\u3001_start\u51fd\u6570\u8be6\u89e3\n\n\u7f51\u4e0a\u67e5\u9605\u8d44\u6599\u4e86\u89e3\u5230u-boot.lds\u4e2d\u7684_start\u4f5c\u4e3a\u542f\u52a8\u7684\u7b2c\u4e00\u8bed\u53e5\uff0c\u7ee7\u7eed\u8ddf_start\u6267\u884c\u7684\u8bed\u53e5\uff0c\u5176\u5b9a\u4e49\u5728vectors.S\n\n```\n_start:\n#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG\n    .word   CONFIG_SYS_DV_NOR_BOOT_CFG\n#endif\n    b   reset\n    ldr pc, _undefined_instruction\n    ldr pc, _software_interrupt\n    ldr pc, _prefetch_abort\n    ldr pc, _data_abort\n    ldr pc, _not_used\n    ldr pc, _irq\n    ldr pc, _fiq\n/*\n *************************************************************************\n *\n * Indirect vectors table\n *\n * Symbols referenced here must be defined somewhere else\n *\n *************************************************************************\n */\n    .globl  _undefined_instruction\n    .globl  _software_interrupt\n    .globl  _prefetch_abort\n    .globl  _data_abort\n    .globl  _not_used\n    .globl  _irq\n    .globl  _fiq\n_undefined_instruction: .word undefined_instruction\n_software_interrupt:    .word software_interrupt\n_prefetch_abort:    .word prefetch_abort\n_data_abort:        .word data_abort\n_not_used:      .word not_used\n_irq:           .word irq\n_fiq:           .word fiq\n    .balignl 16,0xdeadbeef\n```\n\n\u4e2d\u65ad\u5411\u91cf\u8868\u4e2d\uff0c\u5148\u8fdb\u884c\u76f8\u5bf9\u8df3\u8f6c\u5230reset\n\n\u800creset\u51fd\u6570\u5b9a\u4e49\u5728arch/arm/cpu/armv7/start.S\n\n### 2\u3001reset\u51fd\u6570\u8be6\u89e3\n\n```\n#include <asm-offsets.h>\n#include <config.h>\n#include <asm/system.h>\n#include <linux/linkage.h>\n/*************************************************************************\n *\n * Startup Code (reset vector)\n *\n * do important init only if we don't start from memory!\n * setup Memory and board specific bits prior to relocation.\n * relocate armboot to ram\n * setup stack\n *\n *************************************************************************/\n    .globl  reset\n    .globl  save_boot_params_ret\nreset:\n    /* Allow the board to save important registers */\n    b   save_boot_params\n```\n\n\u5728reset\u4e2d\u6267\u884c\u8df3\u8f6c\uff0c\u8df3\u8f6c\u5230save_boot_params\n\n```\nENTRY(save_boot_params)\n    b   save_boot_params_ret        @ back to my caller\nENDPROC(save_boot_params)\n```\n\n\u5728save_boot_params\u4e2d\u6267\u884c\u8df3\u8f6c\uff0c\u8df3\u8f6c\u5230save_boot_params_ret\n\n```\nsave_boot_params_ret:\n    /*\n     * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,\n     * except if in HYP mode already\n     */\n    mrs r0, cpsr\n    and r1, r0, #0x1f       @ mask mode bits\n    teq r1, #0x1a           @ test for HYP mode\n    bicne r0, r0, #0x1f     @ clear all mode bits\n    orrne r0, r0, #0x13     @ set SVC mode\n    orr r0, r0, #0xc0       @ disable FIQ and IRQ\n    msr cpsr,r0\n/*\n * Setup vector:\n * (OMAP4 spl TEXT_BASE is not 32 byte aligned.\n * Continue to use ROM code vector only in OMAP4 spl)\n */\n#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))\n    /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */\n    mrc p15, 0, r0, c1, c0, 0   @ Read CP15 SCTLR Register\n    bic r0, #CR_V               @ V = 0\n    mcr p15, 0, r0, c1, c0, 0   @ Write CP15 SCTLR Register\n    /* Set vector address in CP15 VBAR register */\n    ldr r0, =_start\n    mcr p15, 0, r0, c12, c0, 0  @Set VBAR\n#endif\n    /* the mask ROM code should have PLL and others stable */\n#ifndef CONFIG_SKIP_LOWLEVEL_INIT\n    bl  cpu_init_cp15\n    bl  cpu_init_crit\n#endif\n    bl  _main \n```\n\n\u5728save_boot_params_ret\u4e2d\u6267\u884c\u6307\u4ee4\uff1a\n\n\u6307\u4ee4\u5206\u6790\uff1a\n\n![20190318104323545](../image/20190318104323545.png)\n\n| \u6307\u4ee4  | \u4f7f\u7528\u65b9\u5f0f                 | \u4f5c\u7528                                                         |\n| :---- | :----------------------- | :----------------------------------------------------------- |\n| mrs   | `mrs r0, cpsr`           | \u8bfb\u53d6\u7279\u6b8a\u5bc4\u5b58\u5668cpsr\u7684\u6570\u636e\uff0c\u5e76\u5c06\u6570\u636e\u5199\u5165\u5230r0\u5bc4\u5b58\u5668\u4e2d           |\n| and   | `and r1, r0, r2`         | \u5c06r2\u548cr0\u5bc4\u5b58\u5668\u7684\u6570\u636e\u76f8\u52a0\u5e76\u5c06\u548c\u5b58\u5230r1\u5bc4\u5b58\u5668\u4e2d                 |\n| teq   | `teq r1, r2`             | \u6d4b\u8bd5r1\u5bc4\u5b58\u5668\u548cr2\u5bc4\u5b58\u5668\u7684\u6570\u636e\u662f\u5426\u76f8\u7b49                         |\n| bic   | bic r1, r1 , r2          | \u6839\u636er2\u4e2d\u6570\u636e\u54ea\u4e2a\u4f4d\u4e3a1\uff0c\u6e05\u9664r1\u5bf9\u5e94\u7684\u4f4d\uff0c\u7136\u540e\u5c06\u7ed3\u679c\u5b58\u5165r1\u3002", "top": 0, "createdAt": 1758215241, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-19", "dateLabelColor": "#0969da"}, "P4": {"htmlDir": "docs/post/u-boot-qi-dong-liu-cheng-zhi- abortboot-wei-an-xia-ctrl+u.html", "labels": ["u-boot\u542f\u52a8linux"], "postTitle": "u-boot\u542f\u52a8\u6d41\u7a0b\u4e4b abortboot\u672a\u6309\u4e0bctrl+u", "postUrl": "post/u-boot-qi-dong-liu-cheng-zhi-%20abortboot-wei-an-xia-ctrl%2Bu.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/4", "commentNum": 0, "wordCount": 36628, "description": "## 1\u3001\u8d77\u521d\u5728cli.c\u8c03\u7528\n\n```\n|-->auto_net_upgrade(u-boot/common/autoboot.c)\n|-->run_command_list(u-boot/common/cli.c)\n    |-->parse_string_outer(u-boot/common/cli_hush.c)\n        |-->setup_string_in_str(u-boot/common/cli_hush.c)\n        |-->parse_stream_outer(u-boot/common/cli_hush.c)\n            |-->initialize_context(u-boot/common/cli_hush.c)\n            |-->update_ifs_map(u-boot/common/cli_hush.c)\n            |-->parse_stream(u-boot/common/cli_hush.c)\n            |-->run_list(u-boot/common/cli_hush.c)\n                |-->run_list_real(u-boot/common/cli_hush.c)\n                    |-->make_list_in(u-boot/common/cli_hush.c)\n                    |-->run_pipe_real(u-boot/common/cli_hush.c)\n                        |-->cmd_process(u-boot/common/command.c)\n                            |-->find_cmd(u-boot/common/command.c)\n                            |-->cmd_call(u-boot/common/command.c)\n                                |-->do_bootz(u-boot/common/cmd_bootm.c)\n                                    |-->\n                |-->free_pipe_list(u-boot/common/cli_hush.c)\n```\n\n## 2\u3001\u8fdb\u5165cli_hush.c\u4e2d\u7684parse_string_outer\n\n### parse_string_outer\u51fd\u6570\u5b9a\u4e49\n\n```\nint parse_string_outer(const char *s, int flag)\n{\n    struct in_str input;\n    char *p = NULL;\n    int rcode;\n    if (!s)\n        return 1;\n    if (!*s)\n        return 0;\n    if (!(p = strchr(s, '\\n')) || *++p) {\n        p = xmalloc(strlen(s) + 2);\n        strcpy(p, s);\n        strcat(p, '\\n');\n        setup_string_in_str(&input, p);\n        rcode = parse_stream_outer(&input, flag);\n        free(p);\n        return rcode;\n    } else {\n    setup_string_in_str(&input, s);\n    return parse_stream_outer(&input, flag);\n    }\n}\n```\n\n### parse_stream_outer\u51fd\u6570\u5b9a\u4e49\n\n```\nstatic int parse_stream_outer(struct in_str *inp, int flag)\n{\n    struct p_context ctx;\n    o_string temp=NULL_O_STRING;\n    int rcode;\n    int code = 1;\n    do {\n        ctx.type = flag;\n        initialize_context(&ctx);\n        update_ifs_map();\n        if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)';$&|', 0);\n        inp->promptmode=1;\n        rcode = parse_stream(&temp, &ctx, inp,\n                     flag & FLAG_CONT_ON_NEWLINE ? -1 : '\\n');\n        if (rcode == 1) flag_repeat = 0;\n        if (rcode != 1 && ctx.old_flag != 0) {\n            syntax();\n            flag_repeat = 0;\n        }\n        if (rcode != 1 && ctx.old_flag == 0) {\n            done_word(&temp, &ctx);\n            done_pipe(&ctx,PIPE_SEQ);\n            code = run_list(ctx.list_head);\n            if (code == -2) {   /* exit */\n                b_free(&temp);\n                code = 0;\n                /* XXX hackish way to not allow exit from main loop */\n                if (inp->peek == file_peek) {\n                    printf('exit not allowed from main input shell.\\n');\n                    continue;\n                }\n                break;\n            }\n            if (code == -1)\n                flag_repeat = 0;\n        } else {\n            if (ctx.old_flag != 0) {\n                free(ctx.stack);\n                b_reset(&temp);\n            }\n            if (inp->__promptme == 0) printf('<INTERRUPT>\\n');\n            inp->__promptme = 1;\n            temp.nonnull = 0;\n            temp.quote = 0;\n            inp->p = NULL;\n            free_pipe_list(ctx.list_head,0);\n        }\n        b_free(&temp);\n    /* loop on syntax errors, return on EOF */\n    } while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP) &&\n        (inp->peek != static_peek || b_peek(inp)));\n    return (code != 0) ? 1 : 0;\n}\n```\n\n\n\n### run_list_real\u51fd\u6570\u5b9a\u4e49\n\n```\nstatic int run_list_real(struct pipe *pi)\n{\n    char *save_name = NULL;\n    char **list = NULL;\n    char **save_list = NULL;\n    struct pipe *rpipe;\n    int flag_rep = 0;\n    int rcode=0, flag_skip=1;\n    int flag_restore = 0;\n    int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */\n    reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;\n    /* check syntax for 'for' */\n    for (rpipe = pi; rpipe; rpipe = rpipe->next) {\n        if ((rpipe->r_mode == RES_IN ||\n            rpipe->r_mode == RES_FOR) &&\n            (rpipe->next == NULL)) {\n                syntax();\n#ifdef __U_BOOT__\n                flag_repeat = 0;\n#endif\n                return 1;\n        }\n        if ((rpipe->r_mode == RES_IN &&\n            (rpipe->next->r_mode == RES_IN &&\n            rpipe->next->progs->argv != NULL))||\n            (rpipe->r_mode == RES_FOR &&\n            rpipe->next->r_mode != RES_IN)) {\n                syntax();\n#ifdef __U_BOOT__\n                flag_repeat = 0;\n#endif\n                return 1;\n        }\n    }\n    for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {\n        if (pi->r_mode == RES_WHILE || pi->r_mode == RES_UNTIL ||\n            pi->r_mode == RES_FOR) {\n#ifdef __U_BOOT__\n                /* check Ctrl-C */\n                ctrlc();\n                if ((had_ctrlc())) {\n                    return 1;\n                }\n#endif\n                flag_restore = 0;\n                if (!rpipe) {\n                    flag_rep = 0;\n                    rpipe = pi;\n                }\n        }\n        rmode = pi->r_mode;\n        debug_printf('rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\\n', rmode, if_code, next_if_code, skip_more_in_this_rmode);\n        if (rmode == skip_more_in_this_rmode && flag_skip) {\n            if (pi->followup == PIPE_SEQ) flag_skip=0;\n            continue;\n        }\n        flag_skip = 1;\n        skip_more_in_this_rmode = RES_XXXX;\n        if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;\n        if (rmode == RES_THEN &&  if_code) continue;\n        if (rmode == RES_ELSE && !if_code) continue;\n        if (rmode == RES_ELIF && !if_code) break;\n        if (rmode == RES_FOR && pi->num_progs) {\n            if (!list) {\n                /* if no variable values after 'in' we skip 'for' */\n                if (!pi->next->progs->argv) continue;\n                /* create list of variable values */\n                list = make_list_in(pi->next->progs->argv,\n                    pi->progs->argv[0]);\n                save_list = list;\n                save_name = pi->progs->argv[0];\n                pi->progs->argv[0] = NULL;\n                flag_rep = 1;\n            }\n            if (!(*list)) {\n                free(pi->progs->argv[0]);\n                free(save_list);\n                list = NULL;\n                flag_rep = 0;\n                pi->progs->argv[0] = save_name;\n                continue;\n            } else {\n                /* insert new value from list for variable */\n                if (pi->progs->argv[0])\n                    free(pi->progs->argv[0]);\n                pi->progs->argv[0] = *list++;\n            }\n        }\n        if (rmode == RES_IN) continue;\n        if (rmode == RES_DO) {\n            if (!flag_rep) continue;\n        }\n        if (rmode == RES_DONE) {\n            if (flag_rep) {\n                flag_restore = 1;\n            } else {\n                rpipe = NULL;\n            }\n        }\n        if (pi->num_progs == 0) continue;\n        rcode = run_pipe_real(pi);\n        debug_printf('run_pipe_real returned %d\\n',rcode);\n        if (rcode < -1) {\n            last_return_code = -rcode - 2;\n            return -2;  /* exit */\n        }\n        last_return_code=(rcode == 0) ? 0 : 1;\n        if ( rmode == RES_IF || rmode == RES_ELIF )\n            next_if_code=rcode;  /* can be overwritten a number of times */\n        if (rmode == RES_WHILE)\n            flag_rep = !last_return_code;\n        if (rmode == RES_UNTIL)\n            flag_rep = last_return_code;\n        if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||\n             (rcode!=EXIT_SUCCESS && pi->followup==PIPE_AND) )\n            skip_more_in_this_rmode=rmode;\n    }\n    return rcode;\n}\n```\n\n\n\n### run_pipe_real\u51fd\u6570\u5b9e\u9645\u8fd0\u884c\u90e8\u5206\uff1a\n\n```\nstatic int run_pipe_real(struct pipe *pi)\n{\n    int i;\n    int nextin;\n    int flag = do_repeat ? CMD_FLAG_REPEAT : 0;\n    struct child_prog *child;\n    char *p;\n    nextin = 0;\n    if (pi->num_progs == 1) child = & (pi->progs[0]);\n     \n    if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {\n        for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }\n        for (i = 0; is_assignment(child->argv[i]); i++) {\n            p = insert_var_value(child->argv[i]);\n            set_local_var(p, 0);\n            if (p != child->argv[i]) {\n                child->sp--;\n                free(p);\n            }\n        }\n        /* Process the command */\n        return cmd_process(flag, child->argc, child->argv,\n                   &flag_repeat, NULL);\n    }\n}\n```\n\n## 3\u3001\u8fdb\u5165\u5230command.c\u4e2d\u7684cmd_process\n\n### cmd_process \u51fd\u6570\u5b9e\u9645\u8fd0\u884c\u90e8\u5206\n\n```\nenum command_ret_t cmd_process(int flag, int argc, char * const argv[],\n                   int *repeatable, ulong *ticks)\n{\n    enum command_ret_t rc = CMD_RET_SUCCESS;\n    cmd_tbl_t *cmdtp;\n    /* Look up command in command table */\n    cmdtp = find_cmd(argv[0]);                  //\u521d\u59cb\u7684cmd\u4e5f\u5c31\u662fargv[0]\u5728\u7ecf\u8fc7find_cmd\u51fd\u6570\u540e\u5c06\u5f97\u5230cmd\u76f8\u5173\u7684\u51fd\u6570\uff1b\u5176\u8fc7\u7a0b\u6682\u4e0d\u6e05\u695a\n                                                //\u4f8b\uff1a\u6b64\u5904\u7684argv[0]\u662fbooz\uff0c\u7ecf\u8fc7find_cmd\u540e\u5f97\u5230cmdtp->cmd\u4e3ado_bootz\n    /* found - check max args */\n    if (argc > cmdtp->maxargs)\n        rc = CMD_RET_USAGE;\n    /* avoid 'bootd' recursion */\n    if (cmdtp->cmd == do_bootd) {\n        if (flag & CMD_FLAG_BOOTD) {\n            puts(''bootd' recursion detected\\n');\n            rc = CMD_RET_FAILURE;\n        } else {\n            flag |= CMD_FLAG_BOOTD;\n        }\n    }\n    /* If OK so far, then do the command */\n    if (!rc) {\n        if (ticks)\n            *ticks = get_timer(0);\n        rc = cmd_call(cmdtp, flag, argc, argv); //cmd\u76f8\u5173\u7684\u51fd\u6570do_bootz\u662f\u5728\u6b64\u51fd\u6570\u4e2d\u6267\u884c\u7684\n        if (ticks)\n            *ticks = get_timer(*ticks);\n        *repeatable &= cmdtp->repeatable;\n    }\n    if (rc == CMD_RET_USAGE)\n        rc = cmd_usage(cmdtp);\n    return rc;\n}\n```\n\n### find_cmd\u51fd\u6570\u5b9e\u9645\u6267\u884c\uff1a\n\n```\n#define ll_entry_start(_type, _list)                    \\\n({                                  \\\n    static char start[0] __aligned(4) __attribute__((unused,    \\\n        section('.u_boot_list_2_'#_list'_1')));         \\\n    (_type *)&start;                        \\\n})\n \n#define ll_entry_end(_type, _list)                  \\\n({                                  \\\n    static char end[0] __aligned(4) __attribute__((unused,  \\\n        section('.u_boot_list_2_'#_list'_3')));         \\\n    (_type *)&end;                          \\\n})\n \n#define ll_entry_count(_type, _list)                    \\\n    ({                              \\\n        _type *start = ll_entry_start(_type, _list);        \\\n        _type *end = ll_entry_end(_type, _list);        \\\n        unsigned int _ll_result = end - start;          \\\n        _ll_result;                     \\\n    })\n \ncmd_tbl_t *find_cmd_tbl(const char *cmd, cmd_tbl_t *table, int table_len)\n{\n    cmd_tbl_t *cmdtp;\n    cmd_tbl_t *cmdtp_temp = table;  /* Init value */\n    const char *p;\n    int len;\n    int n_found = 0;\n    if (!cmd)\n        return NULL;\n    /*\n     * Some commands allow length modifiers (like 'cp.b');\n     * compare command name only until first dot.\n     */\n    len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);\n    for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {\n        if (strncmp(cmd, cmdtp->name, len) == 0) {\n            if (len == strlen(cmdtp->name))\n                return cmdtp;   /* full match */\n            cmdtp_temp = cmdtp; /* abbreviated command ? */\n            n_found++;\n        }\n    }\n    if (n_found == 1) {         /* exactly one match */\n        return cmdtp_temp;\n    }\n    return NULL;    /* not found or ambiguous command */\n}\n \ncmd_tbl_t *find_cmd(const char *cmd)\n{\n    cmd_tbl_t *start = ll_entry_start(cmd_tbl_t, cmd);\n    const int len = ll_entry_count(cmd_tbl_t, cmd);\n    return find_cmd_tbl(cmd, start, len);\n}\n```\n\n### cmd_call\u51fd\u6570\u5b9e\u9645\u6267\u884c\uff1a\n\n```\nstatic int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])\n{\n    int result;\n    result = (cmdtp->cmd)(cmdtp, flag, argc, argv);      //do_bootz\u51fd\u6570\u5728\u6b64\u8c03\u7528\u6267\u884c\n    if (result)\n        debug('Command failed, result=%d', result);\n    return result;\n}\n```\n\n## 4\u3001\u8fdb\u5165\u5230cmd_bootm\u51fd\u6570\u4e2d\u7684do_bootz\n\n### do_bootz\u51fd\u6570\u5b9e\u9645\u6267\u884c\uff1a\n\n```\nint do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])\n{\n    int ret;\n    /* Consume 'bootz' \u6b64\u65f6\u7684argc\u662f4\uff0c\u8868\u793a4\u4e2a\u53c2\u6570\uff0c\u540c\u65f6argv[0]\u662fbootz*/  \n    argc--; argv++;     //\u6b64\u65f6argc\u662f3\uff0c\u8fd8\u67093\u4e2a\u53c2\u6570\uff0c\u540c\u65f6argv[0]\u662fbootz\u5f15\u5bfc\u5185\u6838\u7684\u5730\u57400x2080000\n    if (bootz_start(cmdtp, flag, argc, argv, &images))          //images\u5f53\u524d\u8fd8\u53ea\u662f\u4e2a\u7a7a\u7684\u7ed3\u6784\u4f53\u5b9e\u4f8b\n        return 1;\n    /*\n     * We are doing the BOOTM_STATE_LOADOS state ourselves, so must\n     * disable interrupts ourselves\n     */\n    bootm_disable_interrupts();\n    images.os.os = IH_OS_LINUX;\n    ret = do_bootm_states(cmdtp, flag, argc, argv,\n                  BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |\n                  BOOTM_STATE_OS_GO,\n                  &images, 1);\n    return ret;\n}\n```\n\n### 1\u3001bootz_start\u51fd\u6570\u5b9e\u9645\u6267\u884c\uff1a\n\n```\nstatic int bootz_start(cmd_tbl_t *cmdtp, int flag, int argc,\n            char * const argv[], bootm_headers_t *images)\n{\n    int ret;\n    ulong zi_start, zi_end;\n    ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START,\n                  images, 1);\n    /* Setup Linux kernel zImage entry point */\n    if (!argc) {\n        images->ep = load_addr;\n        debug('*  kernel: default image load address = 0x%08lx\\n',\n                load_addr);\n    } else {\n        images->ep = simple_strtoul(argv[0], NULL, 16);\n        debug('*  kernel: cmdline image address = 0x%08lx\\n',\n            images->ep);\n    }\n    printf('images-ep %x\\n', images->ep);\n    ret = bootz_setup(images->ep, &zi_start, &zi_end);\n    if (ret != 0)\n        return 1;\n    lmb_reserve(&images->lmb, images->ep, zi_end - zi_start);\n    /*\n     * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not\n     * have a header that provide this informaiton.\n     */\n    if (bootm_find_ramdisk_fdt(flag, argc, argv))\n        return 1;\n    return 0;\n}\n```\n\n### do_bootm_states\u51fd\u6570\u5b9a\u4e49\n\n```\n int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],\n            int states, bootm_headers_t *images, int boot_progress)\n{\n    boot_os_fn *boot_fn;\n    ulong iflag = 0;\n    int ret = 0, need_boot_fn;\n    images->state |= states;\n    /*\n     * Work through the states and see how far we get. We stop on\n     * any error.\n     */\n    if (states & BOOTM_STATE_START)                     //states=1,ret=0;BOOTM_STATE_START=(0x00000001);\n        ret = bootm_start(cmdtp, flag, argc, argv);     //\u5728\u672c\u51fd\u6570\u4e2d\u552f\u4e8c\u9700\u8981\u6b63\u5e38\u6267\u884c\u7684\u51fd\u6570\u4e4b\u4e00\n    if (!ret && (states & BOOTM_STATE_FINDOS))          //states=1,ret=0;BOOTM_STATE_FINDOS=(0x00000002);\n        ret = bootm_find_os(cmdtp, flag, argc, argv);  \n    if (!ret && (states & BOOTM_STATE_FINDOTHER)) {     //states=1,ret=0;BOOTM_STATE_FINDOTHER=(0x00000004);\n        ret = bootm_find_other(cmdtp, flag, argc, argv);\n        argc = 0;   /* consume the args */\n    }\n    /* From now on, we need the OS boot function */     //\u6b64\u65f6states=1,ret=0;\n    if (ret)\n        return ret;\n    boot_fn = bootm_os_get_boot_func(images->os.os); //\u5728\u672c\u51fd\u6570\u4e2d\u552f\u4e8c\u9700\u8981\u6b63\u5e38\u6267\u884c\u7684\u51fd\u6570\u4e4b\u4e00\n    need_boot_fn = states & (BOOTM_STATE_OS_CMDLINE |\n            BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |\n            BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);        //\u8fd9\u90e8\u5206\u7684\u5b8f0x00000 7E 0\n    /* Call various other states that are not generally used */ //\u6b64\u65f6boot_fn = NULL,need_boot_fn = 0x700\n    if (!ret && (states & BOOTM_STATE_OS_CMDLINE))              //states=1,ret=0;BOOTM_STATE_OS_CMDLINE=(0x00000040);\n        ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);\n    if (!ret && (states & BOOTM_STATE_OS_BD_T))                 //states=1,ret=0;BOOTM_STATE_OS_BD_T=(0x00000080);\n        ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images);\n    if (!ret && (states & BOOTM_STATE_OS_PREP))                 //states=1,ret=0;BOOTM_STATE_OS_PREP=(0x00000100);\n        ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);\n    /* Check for unsupported subcommand. */\n    if (ret) {\n        puts('subcommand not supported\\n');\n        return ret;\n    }\n    /* Now run the OS! We hope this doesn't return */\n    if (!ret && (states & BOOTM_STATE_OS_GO))                   //ret =0;states =1;BOOTM_STATE_OS_GO=0x00000400;\n        ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,\n                images, boot_fn);\n    /* Deal with any fallout */\nerr:\n    if (iflag)                                          //iflag= 0;ret =0;\n        enable_interrupts();\n    if (ret == BOOTM_ERR_UNIMPLEMENTED)\n        bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);\n    else if (ret == BOOTM_ERR_RESET)\n        do_reset(cmdtp, flag, argc, argv);\n    return ret;\n}\n```\n\n#### bootm_start\u51fd\u6570\u5b9a\u4e49\u5b9e\u9645\u6267\u884c\uff1a\n\n```\nstatic int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc,\n               char * const argv[])\n{\n    memset((void *)&images, 0, sizeof(images));\n    images.verify = getenv_yesno('verify');       //\u4ece\u73af\u5883\u53d8\u91cf\u4e2d\u83b7\u53d6verify\u7684\u503c\n    boot_start_lmb(&images);\n    bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, 'bootm_start');\n    images.state = BOOTM_STATE_START;\n    return 0;\n}\n```\n\n#### 1\u3001getenv_yesno\u51fd\u6570\u5b9a\u4e49 \u5b9e\u9645\u6267\u884c\uff1a\n\n```\nchar *getenv(const char *name)\n{\n    if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */\n        ENTRY e, *ep;\n        WATCHDOG_RESET();\n        e.key   = name;                         //\u5c06\u9700\u8981\u67e5\u627e\u7684\u53d8\u91cf\u8f6c\u4e3aENTRY\u7ed3\u6784\u4f53\u53d8\u91cf\u7684\u952e\u503c\n        e.data  = NULL;\n        hsearch_r(e, FIND, &ep, &env_htab, 0);\n        return ep ? ep->data : NULL;\n    }\n    /* restricted capabilities before import */\n    if (getenv_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)\n        return (char *)(gd->env_buf);\n    return NULL;\n}\nint getenv_yesno(const char *var)\n{\n    char *s = getenv(var);\n    if (s == NULL)\n        return -1;\n    return (*s == '1' || *s == 'y' || *s == 'Y' || *s == 't' || *s == 'T') ?\n        1 : 0;\n}\n```\n\ngetenv\u51fd\u6570\u5b9a\u4e49\uff1a\n\n\u672c\u51fd\u6570\u6d89\u53ca\u5230env\u53d8\u91cf\u7684\u76f8\u5173\u4fee\u6539\uff0c\u5b9e\u9645\u89e3\u6790\u6682\u672a\u5b8c\u6210\uff0c\u4ec5\u4ec5\u521d\u6b65\u5b8c\u6210hsearch_r\u51fd\u6570\u7684\u7406\u89e3\uff08\uff09\uff0cgetenc_f\u51fd\u6570\u7684\u7406\u89e3\u5206\u6790\u6682\u672a\u5b8c\u6210\u56e0\u4e3a\u597d\u50cf\u5f88\u591a\u5730\u65b9\u5747\u6709\u76f8\u5173\u7684\u8c03\u7528\u5bfc\u81f4\u6253\u5370\u4fe1\u606f\u6bd4\u8f83\u6742\u4e0d\u597d\u786e\u5b9a\n\nhsearch_r\u51fd\u6570\u5b9a\u4e49\n\n```\nint hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,\n          struct hsearch_data *htab, int flag)\n{\n    unsigned int hval;\n    unsigned int count;\n    unsigned int len = strlen(item.key);\n    unsigned int idx;\n    unsigned int first_deleted = 0;\n    int ret;\n    /* Compute an value for the given string. Perhaps use a better method. */\n    hval = len;\n    count = len;\n    //hash\u8868\u952e\u503c\u751f\u6210\u7b97\u6cd5:\n    //\u5c06item.key---\u73af\u5883\u53d8\u91cfname\u4e2d\u7684\u5b57\u7b26\u79fb\u4f4d\u5e76\u7d2f\u52a0\uff0c\u7136\u540e\u6a21hash\u8868\u9879\u6570\uff0c\u5373\u4e3a\u8be5\u73af\u5883\u53d8\u91cf\u5728hash\u8868\u9879\u4e2d\u7684\u6570\u7ec4\u7d22\u5f15---hash\u8868\u952e\u503c\u3002", "top": 0, "createdAt": 1758216055, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-19", "dateLabelColor": "#0969da"}, "P5": {"htmlDir": "docs/post/ARM linux-qi-dong-liu-cheng.html", "labels": ["bootloader", "ARM linux\u542f\u52a8\u6d41\u7a0b"], "postTitle": "ARM linux\u542f\u52a8\u6d41\u7a0b", "postUrl": "post/ARM%20linux-qi-dong-liu-cheng.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/5", "commentNum": 0, "wordCount": 421, "description": "# BootROM\n\n\u6b64\u7a0b\u5e8f\u51fa\u5382\u56fa\u5316\u5728soc\u5185\u90e8rom\u4e2d\uff0csoc\u4e0a\u7535\u9996\u5148\u6267\u884c\uff0c\u4e3b\u8981\u4f5c\u7528\uff1a\n\n1. \u521d\u59cb\u5316\u65f6\u949f\u3001SRAM\n2. \u6839\u636e\u5bc4\u5b58\u5668\u9009\u62e9\u542f\u52a8\u4ecb\u8d28\n3. \u4ece\u542f\u52a8\u4ecb\u8d28\u642c\u8fd0loader\u5230SRAM\u6267\u884c\n\n# Loader\n\n\u7531\u4e8eSRAM\u4e00\u822c\u8f83\u5c0f\uff0c\u6240\u4ee5loader\u4f53\u79ef\u8f83\u5c0f\uff0c\u4e3b\u8981\u5b8c\u6210\u4ee5\u4e0b\u529f\u80fd\uff1a\n\n1. \u521d\u59cb\u5316DRAM\n2. \u642c\u8fd0U-Boot\u4ee3\u7801\u5230DRAM\u6267\u884c\n\n# U-Boot\n\nU-Boot\u542f\u52a8\u4ee5\u91cd\u5b9a\u4f4d\uff08relocate\uff09\u64cd\u4f5c\u5206\u6210\u4e24\u4e2a\u9636\u6bb5\n\n1. \u91cd\u5b9a\u4f4d\u524d\uff08board_init_f\uff09\uff1a\u53ea\u505a\u5fc5\u8981\u7684\u521d\u59cb\u5316\uff0csoc\u3001\u65f6\u949f\u3001DRAM\u3001\u4e32\u53e3\n2. \u91cd\u5b9a\u4f4d\uff08relocate\uff09\uff1a\u5c06\u81ea\u8eab\u642c\u79fb\u5230DRAM\u7684\u672b\u5c3e\u5730\u5740\u6267\u884c\n3. \u91cd\u5b9a\u4f4d\u540e\uff08board_init_r\uff09\uff1a\u521d\u59cb\u5316\u9700\u8981\u7684\u5916\u8bbe\uff08\u5b58\u50a8\u3001\u7f51\u7edc\u7b49\uff09\uff0c\u547d\u4ee4\u884c\u7cfb\u7edf\uff0c\u5f15\u5bfc\u5185\u6838\n\n# Kernel\n\n1. \u89e3\u6790\u547d\u4ee4\u884c\u53c2\u6570\n2. initcall\u5404\u7c7b\u9a71\u52a8\u521d\u59cb\u5316\n3. \u6302\u8f7d\u6839\u6587\u4ef6\u7cfb\u7edf\n4. \u542f\u52a8init\u8fdb\u7a0b\uff0c\u8fdb\u5165\u7528\u6237\u7a7a\u95f4\u3002", "top": 0, "createdAt": 1758216218, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-19", "dateLabelColor": "#0969da"}, "P6": {"htmlDir": "docs/post/an-quan-qi-dong-secure_boot.html", "labels": ["bootloader"], "postTitle": "\u5b89\u5168\u542f\u52a8secure_boot", "postUrl": "post/an-quan-qi-dong-secure_boot.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/6", "commentNum": 0, "description": "", "wordCount": 0, "top": 0, "createdAt": 1758216598, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-19", "dateLabelColor": "#0969da"}, "P7": {"htmlDir": "docs/post/mian-jing-zong-jie.html", "labels": ["\u9762\u7ecf"], "postTitle": "\u9762\u7ecf\u603b\u7ed3", "postUrl": "post/mian-jing-zong-jie.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/7", "commentNum": 0, "wordCount": 548, "description": "**linux system\u90e8\u5206**\uff08\u6280\u672f\u6df1\u5ea6\uff09\n\n1\u3001\u4e2d\u65ad\u4e0b\u534a\u90e8\u6709\u54ea\u4e9b\u65b9\u5f0f\u5b9e\u73b0\n2\u3001\u5185\u6838\u8fdb\u7a0b\u548c\u7528\u6237\u8fdb\u7a0b\u7684\u533a\u522b\n3\u3001\u51fd\u6570\u591a\u5c42\u5d4c\u5957\u8c03\u7528\u60c5\u51b5\u4e0b\u5176\u53c2\u6570\u662f\u5982\u4f55\u4f20\u9012\u7684\uff1b\u7f16\u8bd1\u7684\u4f18\u5316\u7b49\u7ea7\u4f1a\u5bf9\u8fd9\u4e9b\u9020\u6210\u4ec0\u4e48\u6837\u7684\u5f71\u54cd\n4\u3001CPU\u4e2d\u65ad\u7684\u6267\u884c\u8fc7\u7a0b\n\n**\u603b\u7ebf\u90e8\u5206**\uff08\u57fa\u7840\u592f\u5b9e\uff09\n\n1\u3001I2C \u4fe1\u53f7\u7684\u57fa\u672c\u7c7b\u578b\u53ca\u8bc6\u522b\uff1bi2c\u8bbe\u5907\u5982\u4f55\u6302\u5230i2c\u7ebf\u4e0a\u53bb\u7684\uff0ci2c\u901a\u4fe1\u6240\u7528\u5230\u7684\u63a5\u53e3\u6709\u54ea\u4e9b\uff08\u5185\u6838\u4e0b\uff09\uff0c\u901a\u4fe1\u5f02\u5e38\u4e00\u822c\u6709\u4e9b\u60c5\u51b5\uff0c\u4e00\u822c\u5f80\u54ea\u4e9b\u65b9\u5411\u53bb\u8003\u8651\u3002", "top": 0, "createdAt": 1758375915, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-20", "dateLabelColor": "#0969da"}, "P8": {"htmlDir": "docs/post/ji-chu-zhi-shi-\u2014\u2014i2c.html", "labels": ["\u57fa\u7840\u77e5\u8bc6\u2014\u2014\u5916\u8bbe\u603b\u7ebf"], "postTitle": "\u57fa\u7840\u77e5\u8bc6\u2014\u2014i2c", "postUrl": "post/ji-chu-zhi-shi-%E2%80%94%E2%80%94i2c.html", "postSourceUrl": "https://github.com/nobody-ZWQ/nobody-ZWQ.github.io/issues/8", "commentNum": 0, "description": "", "wordCount": 0, "top": 0, "createdAt": 1758376602, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-09-20", "dateLabelColor": "#0969da"}}, "singeListJson": {}, "labelColorDict": {"ARM linux\u542f\u52a8\u6d41\u7a0b": "#851811", "bootloader": "#8b731a", "bug": "#d73a4a", "camera": "#f9e403", "documentation": "#0075ca", "duplicate": "#cfd3d7", "enhancement": "#a2eeef", "good first issue": "#7057ff", "help wanted": "#008672", "invalid": "#e4e669", "question": "#d876e3", "RISC-V\u5b66\u4e60": "#9fcee7", "u-boot\u542f\u52a8linux": "#92fe41", "USB": "#18f954", "wontfix": "#ffffff", "\u4e2d\u65ad": "#f67da5", "\u57fa\u7840\u77e5\u8bc6\u2014\u2014\u5916\u8bbe\u603b\u7ebf": "#ec4a85", "\u5b58\u50a8": "#8022d9", "\u663e\u793a": "#2197bb", "\u9762\u7ecf": "#524efe"}, "displayTitle": "Blog Title", "faviconUrl": "https://github.githubassets.com/favicons/favicon.svg", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://nobody-ZWQ.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}